<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# xiter

```go
import "github.com/dashjay/xiter/pkg/xiter"
```

Package xiter provides the abstraction of map, slice or channel types into iterators for common processing In most scenarios, we DO NOT need to use the xiter package directly

WARNING: golang 1.23 has higher performance on iterating Seq/Seq2 which boost by coroutine we provide for low golang version just for compatible usage

## Index

- [func AllFromSeq\[T any\]\(seq Seq\[T\], f func\(T\) bool\) bool](<#AllFromSeq>)
- [func AnyFromSeq\[T any\]\(seq Seq\[T\], f func\(T\) bool\) bool](<#AnyFromSeq>)
- [func At\[T any\]\(seq Seq\[T\], index int\) optional.O\[T\]](<#At>)
- [func AvgByFromSeq\[V any, T constraints.Number\]\(seq Seq\[V\], f func\(V\) T\) float64](<#AvgByFromSeq>)
- [func AvgFromSeq\[T constraints.Number\]\(seq Seq\[T\]\) float64](<#AvgFromSeq>)
- [func Contains\[T comparable\]\(seq Seq\[T\], in T\) bool](<#Contains>)
- [func ContainsAll\[T comparable\]\(seq Seq\[T\], in \[\]T\) bool](<#ContainsAll>)
- [func ContainsAny\[T comparable\]\(seq Seq\[T\], in \[\]T\) bool](<#ContainsAny>)
- [func ContainsBy\[T any\]\(seq Seq\[T\], f func\(T\) bool\) bool](<#ContainsBy>)
- [func Count\[T any\]\(seq Seq\[T\]\) int](<#Count>)
- [func Equal\[V comparable\]\(x, y Seq\[V\]\) bool](<#Equal>)
- [func Equal2\[K, V comparable\]\(x, y Seq2\[K, V\]\) bool](<#Equal2>)
- [func EqualFunc\[V1, V2 any\]\(x Seq\[V1\], y Seq\[V2\], f func\(V1, V2\) bool\) bool](<#EqualFunc>)
- [func EqualFunc2\[K1, V1, K2, V2 any\]\(x Seq2\[K1, V1\], y Seq2\[K2, V2\], f func\(K1, V1, K2, V2\) bool\) bool](<#EqualFunc2>)
- [func Find\[T any\]\(seq Seq\[T\], f func\(T\) bool\) \(val T, found bool\)](<#Find>)
- [func FindO\[T any\]\(seq Seq\[T\], f func\(T\) bool\) optional.O\[T\]](<#FindO>)
- [func ForEach\[T any\]\(seq Seq\[T\], f func\(T\) bool\)](<#ForEach>)
- [func ForEachIdx\[T any\]\(seq Seq\[T\], f func\(idx int, v T\) bool\)](<#ForEachIdx>)
- [func Head\[T any\]\(seq Seq\[T\]\) \(v T, hasOne bool\)](<#Head>)
- [func HeadO\[T any\]\(seq Seq\[T\]\) optional.O\[T\]](<#HeadO>)
- [func Index\[T comparable\]\(seq Seq\[T\], v T\) int](<#Index>)
- [func Join\[T \~string\]\(seq Seq\[T\], sep T\) T](<#Join>)
- [func Max\[T constraints.Ordered\]\(seq Seq\[T\]\) \(r optional.O\[T\]\)](<#Max>)
- [func MaxBy\[T constraints.Ordered\]\(seq Seq\[T\], less func\(T, T\) bool\) \(r optional.O\[T\]\)](<#MaxBy>)
- [func Min\[T constraints.Ordered\]\(seq Seq\[T\]\) \(r optional.O\[T\]\)](<#Min>)
- [func MinBy\[T constraints.Ordered\]\(seq Seq\[T\], less func\(T, T\) bool\) \(r optional.O\[T\]\)](<#MinBy>)
- [func Pull\[V any\]\(seq Seq\[V\]\) \(next func\(\) \(V, bool\), stop func\(\)\)](<#Pull>)
- [func Pull2\[K, V any\]\(seq Seq2\[K, V\]\) \(next func\(\) \(K, V, bool\), stop func\(\)\)](<#Pull2>)
- [func Reduce\[Sum, V any\]\(f func\(Sum, V\) Sum, sum Sum, seq Seq\[V\]\) Sum](<#Reduce>)
- [func Reduce2\[Sum, K, V any\]\(f func\(Sum, K, V\) Sum, sum Sum, seq Seq2\[K, V\]\) Sum](<#Reduce2>)
- [func Sum\[T constraints.Number\]\(seq Seq\[T\]\) T](<#Sum>)
- [func ToMap\[K comparable, V any\]\(seq Seq2\[K, V\]\) \(out map\[K\]V\)](<#ToMap>)
- [func ToSlice\[T any\]\(seq Seq\[T\]\) \(out \[\]T\)](<#ToSlice>)
- [func ToSliceN\[T any\]\(seq Seq\[T\], n int\) \(out \[\]T\)](<#ToSliceN>)
- [func ToSliceSeq2Key\[K, V any\]\(seq Seq2\[K, V\]\) \(out \[\]K\)](<#ToSliceSeq2Key>)
- [func ToSliceSeq2Value\[K, V any\]\(seq Seq2\[K, V\]\) \(out \[\]V\)](<#ToSliceSeq2Value>)
- [type Seq](<#Seq>)
  - [func Chunk\[T any\]\(seq Seq\[T\], n int\) Seq\[\[\]T\]](<#Chunk>)
  - [func Concat\[V any\]\(seqs ...Seq\[V\]\) Seq\[V\]](<#Concat>)
  - [func Filter\[V any\]\(f func\(V\) bool, seq Seq\[V\]\) Seq\[V\]](<#Filter>)
  - [func FromChan\[T any\]\(in \<\-chan T\) Seq\[T\]](<#FromChan>)
  - [func FromMapKeys\[K comparable, V any\]\(m map\[K\]V\) Seq\[K\]](<#FromMapKeys>)
  - [func FromMapValues\[K comparable, V any\]\(m map\[K\]V\) Seq\[V\]](<#FromMapValues>)
  - [func FromSlice\[T any\]\(in \[\]T\) Seq\[T\]](<#FromSlice>)
  - [func FromSliceReverse\[T any, Slice \~\[\]T\]\(in Slice\) Seq\[T\]](<#FromSliceReverse>)
  - [func FromSliceShuffle\[T any\]\(in \[\]T\) Seq\[T\]](<#FromSliceShuffle>)
  - [func Limit\[V any\]\(seq Seq\[V\], n int\) Seq\[V\]](<#Limit>)
  - [func Map\[In, Out any\]\(f func\(In\) Out, seq Seq\[In\]\) Seq\[Out\]](<#Map>)
  - [func Merge\[V cmp.Ordered\]\(x, y Seq\[V\]\) Seq\[V\]](<#Merge>)
  - [func MergeFunc\[V any\]\(x, y Seq\[V\], f func\(V, V\) int\) Seq\[V\]](<#MergeFunc>)
  - [func Repeat\[T any\]\(seq Seq\[T\], count int\) Seq\[T\]](<#Repeat>)
  - [func Replace\[T comparable\]\(seq Seq\[T\], from, to T, n int\) Seq\[T\]](<#Replace>)
  - [func ReplaceAll\[T comparable\]\(seq Seq\[T\], from, to T\) Seq\[T\]](<#ReplaceAll>)
  - [func Reverse\[T any\]\(seq Seq\[T\]\) Seq\[T\]](<#Reverse>)
  - [func Seq2KeyToSeq\[K, V any\]\(in Seq2\[K, V\]\) Seq\[K\]](<#Seq2KeyToSeq>)
  - [func Seq2ToSeqUnion\[K, V any\]\(seq Seq2\[K, V\]\) Seq\[union.U2\[K, V\]\]](<#Seq2ToSeqUnion>)
  - [func Seq2ValueToSeq\[K, V any\]\(in Seq2\[K, V\]\) Seq\[V\]](<#Seq2ValueToSeq>)
  - [func Skip\[T any\]\(seq Seq\[T\], n int\) Seq\[T\]](<#Skip>)
  - [func Zip\[V1, V2 any\]\(x Seq\[V1\], y Seq\[V2\]\) Seq\[Zipped\[V1, V2\]\]](<#Zip>)
  - [func Zip2\[K1, V1, K2, V2 any\]\(x Seq2\[K1, V1\], y Seq2\[K2, V2\]\) Seq\[Zipped2\[K1, V1, K2, V2\]\]](<#Zip2>)
- [type Seq2](<#Seq2>)
  - [func Concat2\[K, V any\]\(seqs ...Seq2\[K, V\]\) Seq2\[K, V\]](<#Concat2>)
  - [func Filter2\[K, V any\]\(f func\(K, V\) bool, seq Seq2\[K, V\]\) Seq2\[K, V\]](<#Filter2>)
  - [func FromMapKeyAndValues\[K comparable, V any\]\(m map\[K\]V\) Seq2\[K, V\]](<#FromMapKeyAndValues>)
  - [func FromSliceIdx\[T any\]\(in \[\]T\) Seq2\[int, T\]](<#FromSliceIdx>)
  - [func Limit2\[K, V any\]\(seq Seq2\[K, V\], n int\) Seq2\[K, V\]](<#Limit2>)
  - [func Map2\[KIn, VIn, KOut, VOut any\]\(f func\(KIn, VIn\) \(KOut, VOut\), seq Seq2\[KIn, VIn\]\) Seq2\[KOut, VOut\]](<#Map2>)
  - [func Merge2\[K cmp.Ordered, V any\]\(x, y Seq2\[K, V\]\) Seq2\[K, V\]](<#Merge2>)
  - [func MergeFunc2\[K, V any\]\(x, y Seq2\[K, V\], f func\(K, K\) int\) Seq2\[K, V\]](<#MergeFunc2>)
- [type Zipped](<#Zipped>)
- [type Zipped2](<#Zipped2>)


<a name="AllFromSeq"></a>
## func [AllFromSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L536>)

```go
func AllFromSeq[T any](seq Seq[T], f func(T) bool) bool
```

AllFromSeq return true if all elements from seq satisfy the condition evaluated by f.

<a name="AnyFromSeq"></a>
## func [AnyFromSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L546>)

```go
func AnyFromSeq[T any](seq Seq[T], f func(T) bool) bool
```

AnyFromSeq return true if any elements from seq satisfy the condition evaluated by f.

<a name="At"></a>
## func [At](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L51>)

```go
func At[T any](seq Seq[T], index int) optional.O[T]
```

At return the element at index from seq.

<a name="AvgByFromSeq"></a>
## func [AvgByFromSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L570>)

```go
func AvgByFromSeq[V any, T constraints.Number](seq Seq[V], f func(V) T) float64
```

AvgByFromSeq return the average value of all elements from seq, evaluated by f.

<a name="AvgFromSeq"></a>
## func [AvgFromSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L556>)

```go
func AvgFromSeq[T constraints.Number](seq Seq[T]) float64
```

AvgFromSeq return the average value of all elements from seq.

<a name="Contains"></a>
## func [Contains](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L584>)

```go
func Contains[T comparable](seq Seq[T], in T) bool
```

Contains return true if v is in seq.

<a name="ContainsAll"></a>
## func [ContainsAll](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L621>)

```go
func ContainsAll[T comparable](seq Seq[T], in []T) bool
```

ContainsAll return true if all elements from seq is in vs.

<a name="ContainsAny"></a>
## func [ContainsAny](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L604>)

```go
func ContainsAny[T comparable](seq Seq[T], in []T) bool
```

ContainsAny return true if any element from seq is in vs.

<a name="ContainsBy"></a>
## func [ContainsBy](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L594>)

```go
func ContainsBy[T any](seq Seq[T], f func(T) bool) bool
```

ContainsBy return true if any element from seq satisfies the condition evaluated by f.

<a name="Count"></a>
## func [Count](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L641>)

```go
func Count[T any](seq Seq[T]) int
```

Count return the number of elements in seq.

<a name="Equal"></a>
## func [Equal](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L79>)

```go
func Equal[V comparable](x, y Seq[V]) bool
```

Equal returns whether the two sequences are equal. It compares elements from both Seq in parallel. If the Seq have different lengths or if any corresponding elements are not equal, it returns false.

Example:

```
seq1 := xiter.FromSlice([]int{1, 2, 3})
seq2 := xiter.FromSlice([]int{1, 2, 3})
seq3 := xiter.FromSlice([]int{1, 2, 4})
fmt.Println(xiter.Equal(seq1, seq2))
fmt.Println(xiter.Equal(seq1, seq3))
// output:
// true
// false
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq1 := xiter.FromSlice([]int{1, 2, 3})
	seq2 := xiter.FromSlice([]int{1, 2, 3})
	seq3 := xiter.FromSlice([]int{1, 2, 4})
	fmt.Println(xiter.Equal(seq1, seq2))
	fmt.Println(xiter.Equal(seq1, seq3))
}
```

#### Output

```
true
false
```

</p>
</details>

<a name="Equal2"></a>
## func [Equal2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L90>)

```go
func Equal2[K, V comparable](x, y Seq2[K, V]) bool
```

Equal2 returns whether the two Seq2 are equal. Like Equal but run with Seq2

<a name="EqualFunc"></a>
## func [EqualFunc](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L113>)

```go
func EqualFunc[V1, V2 any](x Seq[V1], y Seq[V2], f func(V1, V2) bool) bool
```

EqualFunc returns whether the two sequences are equal according to the function f. Example:

```
seq1 := xiter.FromSlice([]int{6, 11, 16})
seq2 := xiter.FromSlice([]int{26, 36, 41})
seq3 := xiter.FromSlice([]int{1, 2, 4})
mod5Eq := func(a int, b int) bool {
	return math.Mod(float64(a), 5) == math.Mod(float64(b), 5)
}
fmt.Println(xiter.EqualFunc(seq1, seq2, mod5Eq))
fmt.Println(xiter.EqualFunc(seq1, seq3, mod5Eq))
// output:
// true
// false
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"
	"math"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq1 := xiter.FromSlice([]int{6, 11, 16})
	seq2 := xiter.FromSlice([]int{26, 36, 41})
	seq3 := xiter.FromSlice([]int{1, 2, 4})
	mod5Eq := func(a int, b int) bool {
		return math.Mod(float64(a), 5) == math.Mod(float64(b), 5)
	}
	fmt.Println(xiter.EqualFunc(seq1, seq2, mod5Eq))
	fmt.Println(xiter.EqualFunc(seq1, seq3, mod5Eq))
}
```

#### Output

```
true
false
```

</p>
</details>

<a name="EqualFunc2"></a>
## func [EqualFunc2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L124>)

```go
func EqualFunc2[K1, V1, K2, V2 any](x Seq2[K1, V1], y Seq2[K2, V2], f func(K1, V1, K2, V2) bool) bool
```

EqualFunc2 returns whether the two sequences are equal according to the function f. Like EqualFunc but run with Seq2

<a name="Find"></a>
## func [Find](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L650>)

```go
func Find[T any](seq Seq[T], f func(T) bool) (val T, found bool)
```

Find return the first element from seq that satisfies the condition evaluated by f with a boolean representing whether it exists.

<a name="FindO"></a>
## func [FindO](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L662>)

```go
func FindO[T any](seq Seq[T], f func(T) bool) optional.O[T]
```

FindO return the first element from seq that satisfies the condition evaluated by f.

<a name="ForEach"></a>
## func [ForEach](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L672>)

```go
func ForEach[T any](seq Seq[T], f func(T) bool)
```

ForEach execute f for each element in seq.

<a name="ForEachIdx"></a>
## func [ForEachIdx](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L681>)

```go
func ForEachIdx[T any](seq Seq[T], f func(idx int, v T) bool)
```

ForEachIdx execute f for each element in seq with its index.

<a name="Head"></a>
## func [Head](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L700>)

```go
func Head[T any](seq Seq[T]) (v T, hasOne bool)
```

Head return the first element from seq with a boolean representing whether it is at least one element in seq.

<a name="HeadO"></a>
## func [HeadO](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L692>)

```go
func HeadO[T any](seq Seq[T]) optional.O[T]
```

HeadO return the first element from seq.

<a name="Index"></a>
## func [Index](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L950>)

```go
func Index[T comparable](seq Seq[T], v T) int
```

Index returns the index of the first element in the sequence that is equal to v. If no such element is found, \-1 is returned.

Example:

```
seq := xiter.FromSlice([]int{1, 2, 3, 4, 5})
idx := xiter.Index(seq, 3)
// idx is 2
```

<a name="Join"></a>
## func [Join](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L710>)

```go
func Join[T ~string](seq Seq[T], sep T) T
```

Join return the concatenation of all elements in seq with sep.

<a name="Max"></a>
## func [Max](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L719>)

```go
func Max[T constraints.Ordered](seq Seq[T]) (r optional.O[T])
```

Max returns the maximum element in seq.

<a name="MaxBy"></a>
## func [MaxBy](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L737>)

```go
func MaxBy[T constraints.Ordered](seq Seq[T], less func(T, T) bool) (r optional.O[T])
```

MaxBy return the maximum element in seq, evaluated by f.

<a name="Min"></a>
## func [Min](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L755>)

```go
func Min[T constraints.Ordered](seq Seq[T]) (r optional.O[T])
```

Min return the minimum element in seq.

<a name="MinBy"></a>
## func [MinBy](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L773>)

```go
func MinBy[T constraints.Ordered](seq Seq[T], less func(T, T) bool) (r optional.O[T])
```

MinBy return the minimum element in seq, evaluated by f.

<a name="Pull"></a>
## func [Pull](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L527>)

```go
func Pull[V any](seq Seq[V]) (next func() (V, bool), stop func())
```

Pull wrapped iter.Pull create an iterator from seq. Example:

```
seq := xiter.FromSlice([]int{1, 2, 3})
next, stop := xiter.Pull(seq)
defer stop()
x, ok := next()
fmt.Println(x, ok)
// output:
// 1 true
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq := xiter.FromSlice([]int{1, 2, 3})
	next, stop := xiter.Pull(seq)
	defer stop()
	x, ok := next()
	fmt.Println(x, ok)
}
```

#### Output

```
1 true
```

</p>
</details>

<a name="Pull2"></a>
## func [Pull2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L531>)

```go
func Pull2[K, V any](seq Seq2[K, V]) (next func() (K, V, bool), stop func())
```



<a name="Reduce"></a>
## func [Reduce](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L349>)

```go
func Reduce[Sum, V any](f func(Sum, V) Sum, sum Sum, seq Seq[V]) Sum
```

Reduce combines the values in seq using f. For each value v in seq, it updates sum = f\(sum, v\) and then returns the final sum. For example, if iterating over seq yields v1, v2, v3, Reduce returns f\(f\(f\(sum, v1\), v2\), v3\). Example:

```
seq1To100 := xiter.FromSlice(_range(1, 101))
sum := xiter.Reduce(func(sum int, v int) int {
	return sum + v
}, 0, seq1To100)
fmt.Println(sum)
// output:
// 5050
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func _range(a, b int) []int {
	var res []int
	for i := a; i < b; i++ {
		res = append(res, i)
	}
	return res
}

func main() {
	seq1To100 := xiter.FromSlice(_range(1, 101))
	sum := xiter.Reduce(func(sum int, v int) int {
		return sum + v
	}, 0, seq1To100)
	fmt.Println(sum)
}
```

#### Output

```
5050
```

</p>
</details>

<a name="Reduce2"></a>
## func [Reduce2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L361>)

```go
func Reduce2[Sum, K, V any](f func(Sum, K, V) Sum, sum Sum, seq Seq2[K, V]) Sum
```

Reduce2 combines the values in seq using f. For each pair k, v in seq, it updates sum = f\(sum, k, v\) and then returns the final sum. For example, if iterating over seq yields \(k1, v1\), \(k2, v2\), \(k3, v3\) Reduce returns f\(f\(f\(sum, k1, v1\), k2, v2\), k3, v3\).

<a name="Sum"></a>
## func [Sum](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L933>)

```go
func Sum[T constraints.Number](seq Seq[T]) T
```

Sum returns the sum of all elements in the sequence.

Example:

```
seq := xiter.FromSlice([]int{1, 2, 3, 4, 5})
sum := xiter.Sum(seq)
// sum is 15
```

<a name="ToMap"></a>
## func [ToMap](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L501>)

```go
func ToMap[K comparable, V any](seq Seq2[K, V]) (out map[K]V)
```



<a name="ToSlice"></a>
## func [ToSlice](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L446>)

```go
func ToSlice[T any](seq Seq[T]) (out []T)
```

ToSlice returns the elements in seq as a slice.

<a name="ToSliceN"></a>
## func [ToSliceN](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L791>)

```go
func ToSliceN[T any](seq Seq[T], n int) (out []T)
```

ToSliceN pull out n elements from seq.

<a name="ToSliceSeq2Key"></a>
## func [ToSliceSeq2Key](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L460>)

```go
func ToSliceSeq2Key[K, V any](seq Seq2[K, V]) (out []K)
```

ToSliceSeq2Key returns the keys in seq as a slice.

Example:

```
seq := FromMap(map[string]int{"a": 1, "b": 2})
keys := ToSliceSeq2Key(seq)
// keys will contain: []string{"a", "b"} (order may vary)
```

<a name="ToSliceSeq2Value"></a>
## func [ToSliceSeq2Value](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L474>)

```go
func ToSliceSeq2Value[K, V any](seq Seq2[K, V]) (out []V)
```

ToSliceSeq2Value returns the values in seq as a slice.

Example:

```
seq := FromMap(map[string]int{"a": 1, "b": 2})
values := ToSliceSeq2Value(seq)
// values will contain: []int{1, 2} (order may vary)
```

<a name="Seq"></a>
## type [Seq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L20>)

Seq is a sequence of elements provided by an iterator\-like function. We made this alias Seq to iter.Seq for providing a compatible interface in lower go versions.

```go
type Seq[V any] iter.Seq[V]
```

<a name="Chunk"></a>
### func [Chunk](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L890>)

```go
func Chunk[T any](seq Seq[T], n int) Seq[[]T]
```

Chunk divides a sequence into chunks of size n, yielding each chunk as a slice. The last chunk may contain fewer than n elements.

Example:

```
seq := xiter.FromSlice([]int{1, 2, 3, 4, 5})
chunkedSeq := xiter.Chunk(seq, 2)
// xiter.ToSlice(chunkedSeq) returns [][]int{{1,2}, {3,4}, {5}}
```

<a name="Concat"></a>
### func [Concat](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L39>)

```go
func Concat[V any](seqs ...Seq[V]) Seq[V]
```

Concat returns a Seq over the concatenation of the sequences. It combines multiple Seqs into a single Seq by iterating each Seq one by one in order.

Example:

```
seq1 := xiter.FromSlice([]int{1, 2})
seq2 := xiter.FromSlice([]int{3, 4})
seq3 := xiter.FromSlice([]int{5, 6})
combined := xiter.Concat(seq1, seq2, seq3)
fmt.Println(xiter.ToSlice(combined))
// output:
// [1 2 3 4 5 6]
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq1 := xiter.FromSlice([]int{1, 2})
	seq2 := xiter.FromSlice([]int{3, 4})
	seq3 := xiter.FromSlice([]int{5, 6})
	combined := xiter.Concat(seq1, seq2, seq3)
	fmt.Println(xiter.ToSlice(combined))
}
```

#### Output

```
[1 2 3 4 5 6]
```

</p>
</details>

<a name="Filter"></a>
### func [Filter](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L141>)

```go
func Filter[V any](f func(V) bool, seq Seq[V]) Seq[V]
```

Filter returns a Seq over seq that only includes the values v for which f\(v\) is true.

Example:

```
seq := FromSlice([]int{1, 2, 3, 4, 5})
evenNumbers := Filter(func(v int) bool { return v%2 == 0 }, seq)
// evenNumbers will yield: 2, 4
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq := xiter.FromSlice([]int{1, 2, 3, 4, 5})
	evenNumbers := xiter.Filter(func(v int) bool { return v%2 == 0 }, seq)
	fmt.Println(xiter.ToSlice(evenNumbers))
}
```

#### Output

```
[2 4]
```

</p>
</details>

<a name="FromChan"></a>
### func [FromChan](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L105>)

```go
func FromChan[T any](in <-chan T) Seq[T]
```

FromChan creates a Seq from a Go channel. It yields elements from the channel until the channel is closed or the consumer stops iterating.

Example:

```
ch := make(chan int, 3)
ch <- 1
ch <- 2
close(ch)

seq := FromChan(ch)

// Iterate over the sequence
_ = ToSlice(seq) // Returns []int{1, 2}
```

<a name="FromMapKeys"></a>
### func [FromMapKeys](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L505>)

```go
func FromMapKeys[K comparable, V any](m map[K]V) Seq[K]
```



<a name="FromMapValues"></a>
### func [FromMapValues](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L509>)

```go
func FromMapValues[K comparable, V any](m map[K]V) Seq[V]
```



<a name="FromSlice"></a>
### func [FromSlice](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L29>)

```go
func FromSlice[T any](in []T) Seq[T]
```

FromSlice received a slice and returned a Seq for this slice.

<a name="FromSliceReverse"></a>
### func [FromSliceReverse](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L60>)

```go
func FromSliceReverse[T any, Slice ~[]T](in Slice) Seq[T]
```



<a name="FromSliceShuffle"></a>
### func [FromSliceShuffle](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L871>)

```go
func FromSliceShuffle[T any](in []T) Seq[T]
```

FromSliceShuffle return a seq that shuffle the elements in the input slice.

Example:

```
seq := FromSlice([]int{1, 2, 3, 4, 5})
shuffledSeq := FromSliceShuffle(ToSlice(seq))
// shuffledSeq will yield a shuffled sequence of 1, 2, 3, 4, 5
```

<a name="Limit"></a>
### func [Limit](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L174>)

```go
func Limit[V any](seq Seq[V], n int) Seq[V]
```

Limit returns an iterator over the first n values of seq. If n is less than or equal to 0, an empty sequence is returned.

Example:

```
seq := xiter.FromSlice([]int{1, 2, 3, 4, 5})
limitedSeq := xiter.Limit(seq, 3)
fmt.Println(xiter.ToSlice(limitedSeq))
// output:
// [1 2 3]
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq := xiter.FromSlice([]int{1, 2, 3, 4, 5})
	limitedSeq := xiter.Limit(seq, 3)
	fmt.Println(xiter.ToSlice(limitedSeq))
}
```

#### Output

```
[1 2 3]
```

</p>
</details>

<a name="Map"></a>
### func [Map](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L219>)

```go
func Map[In, Out any](f func(In) Out, seq Seq[In]) Seq[Out]
```

Map returns a Seq over the results of applying f to each value in seq.

Example:

```
seq := xiter.FromSlice([]int{1, 2, 3})
doubled := xiter.Map(func(v int) int { return v * 2 }, seq)
fmt.Println(xiter.ToSlice(doubled))
// output:
// [2 4 6]
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq := xiter.FromSlice([]int{1, 2, 3})
	doubled := xiter.Map(func(v int) int { return v * 2 }, seq)
	fmt.Println(xiter.ToSlice(doubled))
}
```

#### Output

```
[2 4 6]
```

</p>
</details>

<a name="Merge"></a>
### func [Merge](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L252>)

```go
func Merge[V cmp.Ordered](x, y Seq[V]) Seq[V]
```

Merge merges two sequences of ordered values. Values appear in the output once for each time they appear in x and once for each time they appear in y. If the two input sequences are not ordered, the output sequence will not be ordered, but it will still contain every value from x and y exactly once.

Merge is equivalent to calling MergeFunc with cmp.Compare\[V\] as the ordering function.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	oddSeq := xiter.FromSlice([]int{1, 3, 5})
	evenSeq := xiter.FromSlice([]int{2, 4, 6})
	mergedSeq := xiter.Merge(oddSeq, evenSeq)
	fmt.Println(xiter.ToSlice(mergedSeq))
}
```

#### Output

```
[1 2 3 4 5 6]
```

</p>
</details>

<a name="MergeFunc"></a>
### func [MergeFunc](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L264>)

```go
func MergeFunc[V any](x, y Seq[V], f func(V, V) int) Seq[V]
```

MergeFunc merges two sequences of values ordered by the function f. Values appear in the output once for each time they appear in x and once for each time they appear in y. When equal values appear in both sequences, the output contains the values from x before the values from y. If the two input sequences are not ordered by f, the output sequence will not be ordered by f, but it will still contain every value from x and y exactly once.

<a name="Repeat"></a>
### func [Repeat](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L83>)

```go
func Repeat[T any](seq Seq[T], count int) Seq[T]
```

Repeat return a seq that repeat seq for count times.

<a name="Replace"></a>
### func [Replace](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L836>)

```go
func Replace[T comparable](seq Seq[T], from, to T, n int) Seq[T]
```

Replace return a seq that replace from \-\> to

Example:

```
seq := FromSlice([]int{1, 2, 3, 2, 4})
replacedSeq := Replace(seq, 2, 99, -1) // Replace all 2s with 99
// replacedSeq will yield: 1, 99, 3, 99, 4
```

<a name="ReplaceAll"></a>
### func [ReplaceAll](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L860>)

```go
func ReplaceAll[T comparable](seq Seq[T], from, to T) Seq[T]
```

ReplaceAll return a seq that replace all from \-\> to

Example:

```
seq := FromSlice([]int{1, 2, 3, 2, 4})
replacedSeq := ReplaceAll(seq, 2, 99)
// replacedSeq will yield: 1, 99, 3, 99, 4
```

<a name="Reverse"></a>
### func [Reverse](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L71>)

```go
func Reverse[T any](seq Seq[T]) Seq[T]
```

Reverse return a reversed seq.

<a name="Seq2KeyToSeq"></a>
### func [Seq2KeyToSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L481>)

```go
func Seq2KeyToSeq[K, V any](in Seq2[K, V]) Seq[K]
```



<a name="Seq2ToSeqUnion"></a>
### func [Seq2ToSeqUnion](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L916>)

```go
func Seq2ToSeqUnion[K, V any](seq Seq2[K, V]) Seq[union.U2[K, V]]
```

Seq2ToSeqUnion converts a Seq2 sequence of key\-value pairs to a Seq sequence of union.U2 values. This allows unified processing of both keys and values from a key\-value sequence.

Example:

```
seq2 := func(yield func(int, string) bool) { yield(1, "one"); yield(2, "two") }
for v := range Seq2ToSeqUnion(seq2) {
	// v will be union.U2[int, string] containing either 1, "one", 2, or "two"
}
```

<a name="Seq2ValueToSeq"></a>
### func [Seq2ValueToSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L491>)

```go
func Seq2ValueToSeq[K, V any](in Seq2[K, V]) Seq[V]
```



<a name="Skip"></a>
### func [Skip](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L815>)

```go
func Skip[T any](seq Seq[T], n int) Seq[T]
```

Skip return a seq that skip n elements from seq.

<a name="Zip"></a>
### func [Zip](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L385>)

```go
func Zip[V1, V2 any](x Seq[V1], y Seq[V2]) Seq[Zipped[V1, V2]]
```

Zip returns an iterator that iterates x and y in parallel, yielding Zipped values of successive elements of x and y. If one sequence ends before the other, the iteration continues with Zipped values in which either Ok1 or Ok2 is false, depending on which sequence ended first.

Zip is a useful building block for adapters that process pairs of sequences. For example, Equal can be defined as:

```
func Equal[V comparable](x, y Seq[V]) bool {
	for z := range Zip(x, y) {
		if z.Ok1 != z.Ok2 || z.V1 != z.V2 {
			return false
		}
	}
	return true
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq1 := xiter.FromSlice([]int{1, 2, 3})
	seq2 := xiter.FromSlice([]int{11, 22, 33})
	zipped := xiter.Zip(seq1, seq2)
	out := xiter.ToSlice(zipped)
	for _, o := range out {
		fmt.Println(o.V1, o.V2)
	}
}
```

#### Output

```
1 11
2 22
3 33
```

</p>
</details>

<a name="Zip2"></a>
### func [Zip2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L423>)

```go
func Zip2[K1, V1, K2, V2 any](x Seq2[K1, V1], y Seq2[K2, V2]) Seq[Zipped2[K1, V1, K2, V2]]
```

Zip2 returns an iterator that iterates x and y in parallel, yielding Zipped2 values of successive elements of x and y. If one sequence ends before the other, the iteration continues with Zipped2 values in which either Ok1 or Ok2 is false, depending on which sequence ended first.

Zip2 is a useful building block for adapters that process pairs of sequences. For example, Equal2 can be defined as:

```
func Equal2[K, V comparable](x, y Seq2[K, V]) bool {
	for z := range Zip2(x, y) {
		if z.Ok1 != z.Ok2 || z.K1 != z.K2 || z.V1 != z.V2 {
			return false
		}
	}
	return true
}
```

<a name="Seq2"></a>
## type [Seq2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L24>)

Seq2 is a sequence of key/value pair provided by an iterator\-like function. We made this alias Seq2 to iter.Seq2 for providing a compatible interface in lower go versions.

```go
type Seq2[K, V any] iter.Seq2[K, V]
```

<a name="Concat2"></a>
### func [Concat2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L53>)

```go
func Concat2[K, V any](seqs ...Seq2[K, V]) Seq2[K, V]
```

Concat2 returns an Seq2 over the concatenation of the given Seq2s. Like Concat but run with Seq2

<a name="Filter2"></a>
### func [Filter2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L154>)

```go
func Filter2[K, V any](f func(K, V) bool, seq Seq2[K, V]) Seq2[K, V]
```

Filter2 returns an Seq over seq that only includes the key\-value pairs k, v for which f\(k, v\) is true. Like Filter but run with Seq2

<a name="FromMapKeyAndValues"></a>
### func [FromMapKeyAndValues](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L513>)

```go
func FromMapKeyAndValues[K comparable, V any](m map[K]V) Seq2[K, V]
```



<a name="FromSliceIdx"></a>
### func [FromSliceIdx](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L40>)

```go
func FromSliceIdx[T any](in []T) Seq2[int, T]
```

FromSliceIdx received a slice and returned a Seq2 for this slice, key is index.

<a name="Limit2"></a>
### func [Limit2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L193>)

```go
func Limit2[K, V any](seq Seq2[K, V], n int) Seq2[K, V]
```

Limit2 returns a Seq over Seq2 that stops after n key\-value pairs. Like Limit but run with Seq2

<a name="Map2"></a>
### func [Map2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L231-L233>)

```go
func Map2[KIn, VIn, KOut, VOut any](f func(KIn, VIn) (KOut, VOut), seq Seq2[KIn, VIn]) Seq2[KOut, VOut]
```

Map2 returns a Seq2 over the results of applying f to each key\-value pair in seq. Like Map but run with Seq2

<a name="Merge2"></a>
### func [Merge2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L298>)

```go
func Merge2[K cmp.Ordered, V any](x, y Seq2[K, V]) Seq2[K, V]
```

Merge2 merges two sequences of key\-value pairs ordered by their keys. Pairs appear in the output once for each time they appear in x and once for each time they appear in y. If the two input sequences are not ordered by their keys, the output sequence will not be ordered by its keys, but it will still contain every pair from x and y exactly once.

Merge2 is equivalent to calling MergeFunc2 with cmp.Compare\[K\] as the ordering function.

<a name="MergeFunc2"></a>
### func [MergeFunc2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L310>)

```go
func MergeFunc2[K, V any](x, y Seq2[K, V], f func(K, K) int) Seq2[K, V]
```

MergeFunc2 merges two sequences of key\-value pairs ordered by the function f. Pairs appear in the output once for each time they appear in x and once for each time they appear in y. When pairs with equal keys appear in both sequences, the output contains the pairs from x before the pairs from y. If the two input sequences are not ordered by f, the output sequence will not be ordered by f, but it will still contain every pair from x and y exactly once.

<a name="Zipped"></a>
## type [Zipped](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L21-L26>)

A Zipped is a pair of zipped values, one of which may be missing, drawn from two different sequences.

```go
type Zipped[V1, V2 any] struct {
    V1  V1
    Ok1 bool // whether V1 is present (if not, it will be zero)
    V2  V2
    Ok2 bool // whether V2 is present (if not, it will be zero)
}
```

<a name="Zipped2"></a>
## type [Zipped2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L10-L17>)

A Zipped2 is a pair of zipped key\-value pairs, one of which may be missing, drawn from two different sequences.

```go
type Zipped2[K1, V1, K2, V2 any] struct {
    K1  K1
    V1  V1
    Ok1 bool // whether K1, V1 are present (if not, they will be zero)
    K2  K2
    V2  V2
    Ok2 bool // whether K2, V2 are present (if not, they will be zero)
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
