<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# xmap

```go
import "github.com/dashjay/xiter/pkg/xmap"
```

## Index

- [func Clone\[M \~map\[K\]V, K comparable, V any\]\(m M\) M](<#Clone>)
- [func CoalesceMaps\[M \~map\[K\]V, K comparable, V any\]\(maps ...M\) M](<#CoalesceMaps>)
- [func Copy\[M1 \~map\[K\]V, M2 \~map\[K\]V, K comparable, V any\]\(dst M1, src M2\)](<#Copy>)
- [func Equal\[M1, M2 \~map\[K\]V, K, V comparable\]\(m1 M1, m2 M2\) bool](<#Equal>)
- [func EqualFunc\[M1 \~map\[K\]V1, M2 \~map\[K\]V2, K comparable, V1, V2 any\]\(m1 M1, m2 M2, eq func\(V1, V2\) bool\) bool](<#EqualFunc>)
- [func Filter\[M \~map\[K\]V, K comparable, V any\]\(in M, fn func\(K, V\) bool\) M](<#Filter>)
- [func Keys\[M \~map\[K\]V, K comparable, V any\]\(m M\) \[\]K](<#Keys>)
- [func ToUnionSlice\[M \~map\[K\]V, K comparable, V any\]\(m M\) \[\]union.U2\[K, V\]](<#ToUnionSlice>)
- [func Values\[M \~map\[K\]V, K comparable, V any\]\(m M\) \[\]V](<#Values>)


<a name="Clone"></a>
## func [Clone](<https://github.com/dashjay/xiter/blob/main/pkg/xmap/xmap.go#L13>)

```go
func Clone[M ~map[K]V, K comparable, V any](m M) M
```



<a name="CoalesceMaps"></a>
## func [CoalesceMaps](<https://github.com/dashjay/xiter/blob/main/pkg/xmap/xmap_common.go#L31>)

```go
func CoalesceMaps[M ~map[K]V, K comparable, V any](maps ...M) M
```

CoalesceMaps combines multiple maps into a single map. When duplicate keys are encountered, the value from the rightmost \(last\) map in the input slice takes precedence. It iterates through the input maps, converts them to sequences of key\-value pairs, concatenates these sequences, and then converts the combined sequence back into a new map.

Parameters:

```
maps ...M: A variadic slice of maps of type M. Each map must have comparable keys K and values V.
```

Returns:

```
M: A new map containing all key-value pairs from the input maps, with later maps overriding
   values for duplicate keys.
```

Example:

```
map1 := map[string]int{"a": 1, "b": 2}
map2 := map[string]int{"b": 3, "c": 4}
map3 := map[string]int{"d": 5}

// CoalesceMaps will combine map1, map2, and map3.
// For key "b", the value 3 from map2 will override 2 from map1.
result := CoalesceMaps(map1, map2, map3)
// result will be map[string]int{"a": 1, "b": 3, "c": 4, "d": 5}
```

<a name="Copy"></a>
## func [Copy](<https://github.com/dashjay/xiter/blob/main/pkg/xmap/xmap.go#L25>)

```go
func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2)
```



<a name="Equal"></a>
## func [Equal](<https://github.com/dashjay/xiter/blob/main/pkg/xmap/xmap.go#L17>)

```go
func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool
```



<a name="EqualFunc"></a>
## func [EqualFunc](<https://github.com/dashjay/xiter/blob/main/pkg/xmap/xmap.go#L21>)

```go
func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool
```



<a name="Filter"></a>
## func [Filter](<https://github.com/dashjay/xiter/blob/main/pkg/xmap/xmap_common.go#L48>)

```go
func Filter[M ~map[K]V, K comparable, V any](in M, fn func(K, V) bool) M
```

Filter filters the map by the given function. Example:

```
m := map[string]int{"a": 1, "b": 2, "c": 3}
fn := func(k string, v int) bool {
	return v > 1
}
result := Filter(m, fn)
// result will be map[string]int{"b": 2, "c": 3}
```

<a name="Keys"></a>
## func [Keys](<https://github.com/dashjay/xiter/blob/main/pkg/xmap/xmap.go#L29>)

```go
func Keys[M ~map[K]V, K comparable, V any](m M) []K
```



<a name="ToUnionSlice"></a>
## func [ToUnionSlice](<https://github.com/dashjay/xiter/blob/main/pkg/xmap/xmap.go#L37>)

```go
func ToUnionSlice[M ~map[K]V, K comparable, V any](m M) []union.U2[K, V]
```



<a name="Values"></a>
## func [Values](<https://github.com/dashjay/xiter/blob/main/pkg/xmap/xmap.go#L33>)

```go
func Values[M ~map[K]V, K comparable, V any](m M) []V
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
