<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# xiter

```go
import "github.com/dashjay/xiter"
```

## Index



# cmp

```go
import "github.com/dashjay/xiter/pkg/cmp"
```

## Index

- [func Compare\[T Ordered\]\(x, y T\) int](<#Compare>)
- [func Less\[T Ordered\]\(x, y T\) bool](<#Less>)
- [func Or\[T comparable\]\(vals ...T\) T](<#Or>)
- [type Ordered](<#Ordered>)


<a name="Compare"></a>
## func [Compare](<https://github.com/dashjay/xiter/blob/main/pkg/cmp/cmp.go#L14>)

```go
func Compare[T Ordered](x, y T) int
```



<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"
	"math"

	"github.com/dashjay/xiter/pkg/cmp"
)

func main() {
	fmt.Println(cmp.Compare(1, 2))
	fmt.Println(cmp.Compare("a", "aa"))
	fmt.Println(cmp.Compare(1.5, 1.5))
	fmt.Println(cmp.Compare(math.NaN(), 1.0))
}
```

#### Output

```
-1
-1
0
-1
```

</p>
</details>

<a name="Less"></a>
## func [Less](<https://github.com/dashjay/xiter/blob/main/pkg/cmp/cmp.go#L10>)

```go
func Less[T Ordered](x, y T) bool
```



<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"
	"math"

	"github.com/dashjay/xiter/pkg/cmp"
)

func main() {
	fmt.Println(cmp.Less(1, 2))
	fmt.Println(cmp.Less("a", "aa"))
	fmt.Println(cmp.Less(1.0, math.NaN()))
	fmt.Println(cmp.Less(math.NaN(), 1.0))
}
```

#### Output

```
true
true
false
true
```

</p>
</details>

<a name="Or"></a>
## func [Or](<https://github.com/dashjay/xiter/blob/main/pkg/cmp/cmp.go#L18>)

```go
func Or[T comparable](vals ...T) T
```



<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/cmp"
)

func main() {
	// Suppose we have some user input
	// that may or may not be an empty string
	userInput1 := ""
	userInput2 := "some text"

	fmt.Println(cmp.Or(userInput1, "default"))
	fmt.Println(cmp.Or(userInput2, "default"))
	fmt.Println(cmp.Or(userInput1, userInput2, "default"))
}
```

#### Output

```
default
some text
some text
```

</p>
</details>

<details><summary>Example (Sort)</summary>
<p>



```go
package main

import (
	"fmt"
	"sort"
	"strings"

	"github.com/dashjay/xiter/pkg/cmp"
)

type Order struct {
	Product  string
	Customer string
	Price    float64
}

type Orders []Order

func (o Orders) Len() int {
	return len(o)
}
func (o Orders) Less(i, j int) bool {
	a, b := o[i], o[j]
	if cmp.Or(
		strings.Compare(a.Customer, b.Customer),
		strings.Compare(a.Product, b.Product),
		cmp.Compare(b.Price, a.Price)) < 0 {
		return true
	} else {
		return false
	}
}

func (o Orders) Swap(i, j int) {
	o[i], o[j] = o[j], o[i]
}

func main() {
	orders := []Order{
		{"foo", "alice", 1.00},
		{"bar", "bob", 3.00},
		{"baz", "carol", 4.00},
		{"foo", "alice", 2.00},
		{"bar", "carol", 1.00},
		{"foo", "bob", 4.00},
	}
	//Sort by customer first, product second, and last by higher price
	sort.Sort(Orders(orders))

	// wait for the  implement of slices.SortFunc
	//SortFunc(orders, func(a, b Order) int {
	//	return cmp.Or(
	//		strings.Compare(a.Customer, b.Customer),
	//		strings.Compare(a.Product, b.Product),
	//		cmp.Compare(b.Price, a.Price),
	//	)
	//})
	for _, order := range orders {
		fmt.Printf("%s %s %.2f\n", order.Product, order.Customer, order.Price)
	}

}
```

#### Output

```
foo alice 2.00
foo alice 1.00
bar bob 3.00
foo bob 4.00
bar carol 1.00
baz carol 4.00
```

</p>
</details>

<a name="Ordered"></a>
## type [Ordered](<https://github.com/dashjay/xiter/blob/main/pkg/cmp/cmp.go#L8>)



```go
type Ordered cmp.Ordered
```

# optional

```go
import "github.com/dashjay/xiter/pkg/optional"
```

Package optional provides a type which can be used to represent a value that may or may not be present like option in Rust.

## Index

- [type O](<#O>)
  - [func Empty\[T any\]\(\) O\[T\]](<#Empty>)
  - [func FromValue\[T any\]\(v T\) O\[T\]](<#FromValue>)
  - [func FromValue2\[T any\]\(v T, ok bool\) O\[T\]](<#FromValue2>)
  - [func \(o O\[T\]\) Must\(\) T](<#O[T].Must>)
  - [func \(o O\[T\]\) Ok\(\) bool](<#O[T].Ok>)
  - [func \(o O\[T\]\) Ptr\(\) \*T](<#O[T].Ptr>)
  - [func \(o O\[T\]\) ValueOr\(dft T\) T](<#O[T].ValueOr>)
  - [func \(o O\[T\]\) ValueOrZero\(\) T](<#O[T].ValueOrZero>)


<a name="O"></a>
## type [O](<https://github.com/dashjay/xiter/blob/main/pkg/optional/optional.go#L5-L8>)



```go
type O[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="Empty"></a>
### func [Empty](<https://github.com/dashjay/xiter/blob/main/pkg/optional/optional.go#L27>)

```go
func Empty[T any]() O[T]
```

Empty creates an empty Optional with no value.

<a name="FromValue"></a>
### func [FromValue](<https://github.com/dashjay/xiter/blob/main/pkg/optional/optional.go#L11>)

```go
func FromValue[T any](v T) O[T]
```

FromValue creates an Optional from a value.

<a name="FromValue2"></a>
### func [FromValue2](<https://github.com/dashjay/xiter/blob/main/pkg/optional/optional.go#L22>)

```go
func FromValue2[T any](v T, ok bool) O[T]
```

FromValue2 creates an Optional from a value and a boolean meaning whether the value is valid.

HINT:

```
if we have a function defined as fn () (T, bool),
we can use FromValue2(fn()) instead of
if v, ok := fn(); ok { FromValue(v) } else { Empty[T]() }
```

<a name="O[T].Must"></a>
### func \(O\[T\]\) [Must](<https://github.com/dashjay/xiter/blob/main/pkg/optional/optional.go#L48>)

```go
func (o O[T]) Must() T
```

Must directly return the value of the Optional.

‚ùåWARNING: Panic if the Optional has no value.

<a name="O[T].Ok"></a>
### func \(O\[T\]\) [Ok](<https://github.com/dashjay/xiter/blob/main/pkg/optional/optional.go#L41>)

```go
func (o O[T]) Ok() bool
```

Ok returns whether the Optional has a valid value.

<a name="O[T].Ptr"></a>
### func \(O\[T\]\) [Ptr](<https://github.com/dashjay/xiter/blob/main/pkg/optional/optional.go#L33>)

```go
func (o O[T]) Ptr() *T
```

Ptr returns a pointer to the value of the Optional. return nil if the Optional has no value.

<a name="O[T].ValueOr"></a>
### func \(O\[T\]\) [ValueOr](<https://github.com/dashjay/xiter/blob/main/pkg/optional/optional.go#L56>)

```go
func (o O[T]) ValueOr(dft T) T
```

ValueOr returns the value of the Optional if it has a valid value, otherwise returns the given default value.

<a name="O[T].ValueOrZero"></a>
### func \(O\[T\]\) [ValueOrZero](<https://github.com/dashjay/xiter/blob/main/pkg/optional/optional.go#L64>)

```go
func (o O[T]) ValueOrZero() T
```

ValueOrZero returns the value of the Optional if it has a valid value, otherwise returns the zero value of T.

# union

```go
import "github.com/dashjay/xiter/pkg/union"
```

## Index

- [type U2](<#U2>)
- [type U3](<#U3>)


<a name="U2"></a>
## type [U2](<https://github.com/dashjay/xiter/blob/main/pkg/union/union.go#L3-L6>)



```go
type U2[T1, T2 any] struct {
    T1  T1
    T2  T2
}
```

<a name="U3"></a>
## type [U3](<https://github.com/dashjay/xiter/blob/main/pkg/union/union.go#L8-L12>)



```go
type U3[T1, T2, T3 any] struct {
    T1  T1
    T2  T2
    T3  T3
}
```

# xiter

```go
import "github.com/dashjay/xiter/pkg/xiter"
```

Package xiter provides the abstraction of map, slice or channel types into iterators for common processing In most scenarios, we DO NOT need to use the xiter package directly

WARNING: golang 1.23 has higher performance on iterating Seq/Seq2 which boost by coroutine we provide for low golang version just for compatible usage

## Index

- [func AllFromSeq\[T any\]\(seq Seq\[T\], f func\(T\) bool\) bool](<#AllFromSeq>)
- [func AnyFromSeq\[T any\]\(seq Seq\[T\], f func\(T\) bool\) bool](<#AnyFromSeq>)
- [func At\[T any\]\(seq Seq\[T\], index int\) optional.O\[T\]](<#At>)
- [func AvgByFromSeq\[V any, T constraints.Number\]\(seq Seq\[V\], f func\(V\) T\) float64](<#AvgByFromSeq>)
- [func AvgFromSeq\[T constraints.Number\]\(seq Seq\[T\]\) float64](<#AvgFromSeq>)
- [func Contains\[T comparable\]\(seq Seq\[T\], in T\) bool](<#Contains>)
- [func ContainsAll\[T comparable\]\(seq Seq\[T\], in \[\]T\) bool](<#ContainsAll>)
- [func ContainsAny\[T comparable\]\(seq Seq\[T\], in \[\]T\) bool](<#ContainsAny>)
- [func ContainsBy\[T any\]\(seq Seq\[T\], f func\(T\) bool\) bool](<#ContainsBy>)
- [func Count\[T any\]\(seq Seq\[T\]\) int](<#Count>)
- [func Equal\[V comparable\]\(x, y Seq\[V\]\) bool](<#Equal>)
- [func Equal2\[K, V comparable\]\(x, y Seq2\[K, V\]\) bool](<#Equal2>)
- [func EqualFunc\[V1, V2 any\]\(x Seq\[V1\], y Seq\[V2\], f func\(V1, V2\) bool\) bool](<#EqualFunc>)
- [func EqualFunc2\[K1, V1, K2, V2 any\]\(x Seq2\[K1, V1\], y Seq2\[K2, V2\], f func\(K1, V1, K2, V2\) bool\) bool](<#EqualFunc2>)
- [func Find\[T any\]\(seq Seq\[T\], f func\(T\) bool\) \(val T, found bool\)](<#Find>)
- [func FindO\[T any\]\(seq Seq\[T\], f func\(T\) bool\) optional.O\[T\]](<#FindO>)
- [func ForEach\[T any\]\(seq Seq\[T\], f func\(T\) bool\)](<#ForEach>)
- [func ForEachIdx\[T any\]\(seq Seq\[T\], f func\(idx int, v T\) bool\)](<#ForEachIdx>)
- [func Head\[T any\]\(seq Seq\[T\]\) \(v T, hasOne bool\)](<#Head>)
- [func HeadO\[T any\]\(seq Seq\[T\]\) optional.O\[T\]](<#HeadO>)
- [func Join\[T \~string\]\(seq Seq\[T\], sep T\) T](<#Join>)
- [func Max\[T constraints.Ordered\]\(seq Seq\[T\]\) \(r optional.O\[T\]\)](<#Max>)
- [func MaxBy\[T constraints.Ordered\]\(seq Seq\[T\], less func\(T, T\) bool\) \(r optional.O\[T\]\)](<#MaxBy>)
- [func Min\[T constraints.Ordered\]\(seq Seq\[T\]\) \(r optional.O\[T\]\)](<#Min>)
- [func MinBy\[T constraints.Ordered\]\(seq Seq\[T\], less func\(T, T\) bool\) \(r optional.O\[T\]\)](<#MinBy>)
- [func Pull\[V any\]\(seq Seq\[V\]\) \(next func\(\) \(V, bool\), stop func\(\)\)](<#Pull>)
- [func Pull2\[K, V any\]\(seq Seq2\[K, V\]\) \(next func\(\) \(K, V, bool\), stop func\(\)\)](<#Pull2>)
- [func Reduce\[Sum, V any\]\(f func\(Sum, V\) Sum, sum Sum, seq Seq\[V\]\) Sum](<#Reduce>)
- [func Reduce2\[Sum, K, V any\]\(f func\(Sum, K, V\) Sum, sum Sum, seq Seq2\[K, V\]\) Sum](<#Reduce2>)
- [func ToMap\[K comparable, V any\]\(seq Seq2\[K, V\]\) \(out map\[K\]V\)](<#ToMap>)
- [func ToSlice\[T any\]\(seq Seq\[T\]\) \(out \[\]T\)](<#ToSlice>)
- [func ToSliceN\[T any\]\(seq Seq\[T\], n int\) \(out \[\]T\)](<#ToSliceN>)
- [func ToSliceSeq2Key\[K, V any\]\(seq Seq2\[K, V\]\) \(out \[\]K\)](<#ToSliceSeq2Key>)
- [func ToSliceSeq2Value\[K, V any\]\(seq Seq2\[K, V\]\) \(out \[\]V\)](<#ToSliceSeq2Value>)
- [type Seq](<#Seq>)
  - [func Concat\[V any\]\(seqs ...Seq\[V\]\) Seq\[V\]](<#Concat>)
  - [func Filter\[V any\]\(f func\(V\) bool, seq Seq\[V\]\) Seq\[V\]](<#Filter>)
  - [func FromMapKeys\[K comparable, V any\]\(m map\[K\]V\) Seq\[K\]](<#FromMapKeys>)
  - [func FromMapValues\[K comparable, V any\]\(m map\[K\]V\) Seq\[V\]](<#FromMapValues>)
  - [func FromSlice\[T any\]\(in \[\]T\) Seq\[T\]](<#FromSlice>)
  - [func FromSliceReverse\[T any, Slice \~\[\]T\]\(in Slice\) Seq\[T\]](<#FromSliceReverse>)
  - [func FromSliceShuffle\[T any\]\(in \[\]T\) Seq\[T\]](<#FromSliceShuffle>)
  - [func Limit\[V any\]\(seq Seq\[V\], n int\) Seq\[V\]](<#Limit>)
  - [func Map\[In, Out any\]\(f func\(In\) Out, seq Seq\[In\]\) Seq\[Out\]](<#Map>)
  - [func Merge\[V cmp.Ordered\]\(x, y Seq\[V\]\) Seq\[V\]](<#Merge>)
  - [func MergeFunc\[V any\]\(x, y Seq\[V\], f func\(V, V\) int\) Seq\[V\]](<#MergeFunc>)
  - [func Repeat\[T any\]\(seq Seq\[T\], count int\) Seq\[T\]](<#Repeat>)
  - [func Replace\[T comparable\]\(seq Seq\[T\], from, to T, n int\) Seq\[T\]](<#Replace>)
  - [func ReplaceAll\[T comparable\]\(seq Seq\[T\], from, to T\) Seq\[T\]](<#ReplaceAll>)
  - [func Reverse\[T any\]\(seq Seq\[T\]\) Seq\[T\]](<#Reverse>)
  - [func Seq2KeyToSeq\[K, V any\]\(in Seq2\[K, V\]\) Seq\[K\]](<#Seq2KeyToSeq>)
  - [func Seq2ValueToSeq\[K, V any\]\(in Seq2\[K, V\]\) Seq\[V\]](<#Seq2ValueToSeq>)
  - [func Skip\[T any\]\(seq Seq\[T\], n int\) Seq\[T\]](<#Skip>)
  - [func Zip\[V1, V2 any\]\(x Seq\[V1\], y Seq\[V2\]\) Seq\[Zipped\[V1, V2\]\]](<#Zip>)
  - [func Zip2\[K1, V1, K2, V2 any\]\(x Seq2\[K1, V1\], y Seq2\[K2, V2\]\) Seq\[Zipped2\[K1, V1, K2, V2\]\]](<#Zip2>)
- [type Seq2](<#Seq2>)
  - [func Concat2\[K, V any\]\(seqs ...Seq2\[K, V\]\) Seq2\[K, V\]](<#Concat2>)
  - [func Filter2\[K, V any\]\(f func\(K, V\) bool, seq Seq2\[K, V\]\) Seq2\[K, V\]](<#Filter2>)
  - [func FromMapKeyAndValues\[K comparable, V any\]\(m map\[K\]V\) Seq2\[K, V\]](<#FromMapKeyAndValues>)
  - [func FromSliceIdx\[T any\]\(in \[\]T\) Seq2\[int, T\]](<#FromSliceIdx>)
  - [func Limit2\[K, V any\]\(seq Seq2\[K, V\], n int\) Seq2\[K, V\]](<#Limit2>)
  - [func Map2\[KIn, VIn, KOut, VOut any\]\(f func\(KIn, VIn\) \(KOut, VOut\), seq Seq2\[KIn, VIn\]\) Seq2\[KOut, VOut\]](<#Map2>)
  - [func Merge2\[K cmp.Ordered, V any\]\(x, y Seq2\[K, V\]\) Seq2\[K, V\]](<#Merge2>)
  - [func MergeFunc2\[K, V any\]\(x, y Seq2\[K, V\], f func\(K, K\) int\) Seq2\[K, V\]](<#MergeFunc2>)
- [type Zipped](<#Zipped>)
- [type Zipped2](<#Zipped2>)


<a name="AllFromSeq"></a>
## func [AllFromSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L535>)

```go
func AllFromSeq[T any](seq Seq[T], f func(T) bool) bool
```

AllFromSeq return true if all elements from seq satisfy the condition evaluated by f.

<a name="AnyFromSeq"></a>
## func [AnyFromSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L545>)

```go
func AnyFromSeq[T any](seq Seq[T], f func(T) bool) bool
```

AnyFromSeq return true if any elements from seq satisfy the condition evaluated by f.

<a name="At"></a>
## func [At](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L51>)

```go
func At[T any](seq Seq[T], index int) optional.O[T]
```

At return the element at index from seq.

<a name="AvgByFromSeq"></a>
## func [AvgByFromSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L569>)

```go
func AvgByFromSeq[V any, T constraints.Number](seq Seq[V], f func(V) T) float64
```

AvgByFromSeq return the average value of all elements from seq, evaluated by f.

<a name="AvgFromSeq"></a>
## func [AvgFromSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L555>)

```go
func AvgFromSeq[T constraints.Number](seq Seq[T]) float64
```

AvgFromSeq return the average value of all elements from seq.

<a name="Contains"></a>
## func [Contains](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L583>)

```go
func Contains[T comparable](seq Seq[T], in T) bool
```

Contains return true if v is in seq.

<a name="ContainsAll"></a>
## func [ContainsAll](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L620>)

```go
func ContainsAll[T comparable](seq Seq[T], in []T) bool
```

ContainsAll return true if all elements from seq is in vs.

<a name="ContainsAny"></a>
## func [ContainsAny](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L603>)

```go
func ContainsAny[T comparable](seq Seq[T], in []T) bool
```

ContainsAny return true if any element from seq is in vs.

<a name="ContainsBy"></a>
## func [ContainsBy](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L593>)

```go
func ContainsBy[T any](seq Seq[T], f func(T) bool) bool
```

ContainsBy return true if any element from seq satisfies the condition evaluated by f.

<a name="Count"></a>
## func [Count](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L640>)

```go
func Count[T any](seq Seq[T]) int
```

Count return the number of elements in seq.

<a name="Equal"></a>
## func [Equal](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L78>)

```go
func Equal[V comparable](x, y Seq[V]) bool
```

Equal returns whether the two sequences are equal. It compares elements from both Seq in parallel. If the Seq have different lengths or if any corresponding elements are not equal, it returns false.

Example:

```
seq1 := xiter.FromSlice([]int{1, 2, 3})
seq2 := xiter.FromSlice([]int{1, 2, 3})
seq3 := xiter.FromSlice([]int{1, 2, 4})
fmt.Println(xiter.Equal(seq1, seq2))
fmt.Println(xiter.Equal(seq1, seq3))
// output:
// true
// false
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq1 := xiter.FromSlice([]int{1, 2, 3})
	seq2 := xiter.FromSlice([]int{1, 2, 3})
	seq3 := xiter.FromSlice([]int{1, 2, 4})
	fmt.Println(xiter.Equal(seq1, seq2))
	fmt.Println(xiter.Equal(seq1, seq3))
}
```

#### Output

```
true
false
```

</p>
</details>

<a name="Equal2"></a>
## func [Equal2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L89>)

```go
func Equal2[K, V comparable](x, y Seq2[K, V]) bool
```

Equal2 returns whether the two Seq2 are equal. Like Equal but run with Seq2

<a name="EqualFunc"></a>
## func [EqualFunc](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L112>)

```go
func EqualFunc[V1, V2 any](x Seq[V1], y Seq[V2], f func(V1, V2) bool) bool
```

EqualFunc returns whether the two sequences are equal according to the function f. Example:

```
seq1 := xiter.FromSlice([]int{6, 11, 16})
seq2 := xiter.FromSlice([]int{26, 36, 41})
seq3 := xiter.FromSlice([]int{1, 2, 4})
mod5Eq := func(a int, b int) bool {
	return math.Mod(float64(a), 5) == math.Mod(float64(b), 5)
}
fmt.Println(xiter.EqualFunc(seq1, seq2, mod5Eq))
fmt.Println(xiter.EqualFunc(seq1, seq3, mod5Eq))
// output:
// true
// false
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"
	"math"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq1 := xiter.FromSlice([]int{6, 11, 16})
	seq2 := xiter.FromSlice([]int{26, 36, 41})
	seq3 := xiter.FromSlice([]int{1, 2, 4})
	mod5Eq := func(a int, b int) bool {
		return math.Mod(float64(a), 5) == math.Mod(float64(b), 5)
	}
	fmt.Println(xiter.EqualFunc(seq1, seq2, mod5Eq))
	fmt.Println(xiter.EqualFunc(seq1, seq3, mod5Eq))
}
```

#### Output

```
true
false
```

</p>
</details>

<a name="EqualFunc2"></a>
## func [EqualFunc2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L123>)

```go
func EqualFunc2[K1, V1, K2, V2 any](x Seq2[K1, V1], y Seq2[K2, V2], f func(K1, V1, K2, V2) bool) bool
```

EqualFunc2 returns whether the two sequences are equal according to the function f. Like EqualFunc but run with Seq2

<a name="Find"></a>
## func [Find](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L649>)

```go
func Find[T any](seq Seq[T], f func(T) bool) (val T, found bool)
```

Find return the first element from seq that satisfies the condition evaluated by f with a boolean representing whether it exists.

<a name="FindO"></a>
## func [FindO](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L661>)

```go
func FindO[T any](seq Seq[T], f func(T) bool) optional.O[T]
```

FindO return the first element from seq that satisfies the condition evaluated by f.

<a name="ForEach"></a>
## func [ForEach](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L671>)

```go
func ForEach[T any](seq Seq[T], f func(T) bool)
```

ForEach execute f for each element in seq.

<a name="ForEachIdx"></a>
## func [ForEachIdx](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L680>)

```go
func ForEachIdx[T any](seq Seq[T], f func(idx int, v T) bool)
```

ForEachIdx execute f for each element in seq with its index.

<a name="Head"></a>
## func [Head](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L699>)

```go
func Head[T any](seq Seq[T]) (v T, hasOne bool)
```

Head return the first element from seq with a boolean representing whether it is at least one element in seq.

<a name="HeadO"></a>
## func [HeadO](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L691>)

```go
func HeadO[T any](seq Seq[T]) optional.O[T]
```

HeadO return the first element from seq.

<a name="Join"></a>
## func [Join](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L709>)

```go
func Join[T ~string](seq Seq[T], sep T) T
```

Join return the concatenation of all elements in seq with sep.

<a name="Max"></a>
## func [Max](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L718>)

```go
func Max[T constraints.Ordered](seq Seq[T]) (r optional.O[T])
```

Max returns the maximum element in seq.

<a name="MaxBy"></a>
## func [MaxBy](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L736>)

```go
func MaxBy[T constraints.Ordered](seq Seq[T], less func(T, T) bool) (r optional.O[T])
```

MaxBy return the maximum element in seq, evaluated by f.

<a name="Min"></a>
## func [Min](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L754>)

```go
func Min[T constraints.Ordered](seq Seq[T]) (r optional.O[T])
```

Min return the minimum element in seq.

<a name="MinBy"></a>
## func [MinBy](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L772>)

```go
func MinBy[T constraints.Ordered](seq Seq[T], less func(T, T) bool) (r optional.O[T])
```

MinBy return the minimum element in seq, evaluated by f.

<a name="Pull"></a>
## func [Pull](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L526>)

```go
func Pull[V any](seq Seq[V]) (next func() (V, bool), stop func())
```

Pull wrapped iter.Pull create an iterator from seq. Example:

```
seq := xiter.FromSlice([]int{1, 2, 3})
next, stop := xiter.Pull(seq)
defer stop()
x, ok := next()
fmt.Println(x, ok)
// output:
// 1 true
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq := xiter.FromSlice([]int{1, 2, 3})
	next, stop := xiter.Pull(seq)
	defer stop()
	x, ok := next()
	fmt.Println(x, ok)
}
```

#### Output

```
1 true
```

</p>
</details>

<a name="Pull2"></a>
## func [Pull2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L530>)

```go
func Pull2[K, V any](seq Seq2[K, V]) (next func() (K, V, bool), stop func())
```



<a name="Reduce"></a>
## func [Reduce](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L348>)

```go
func Reduce[Sum, V any](f func(Sum, V) Sum, sum Sum, seq Seq[V]) Sum
```

Reduce combines the values in seq using f. For each value v in seq, it updates sum = f\(sum, v\) and then returns the final sum. For example, if iterating over seq yields v1, v2, v3, Reduce returns f\(f\(f\(sum, v1\), v2\), v3\). Example:

```
seq1To100 := xiter.FromSlice(_range(1, 101))
sum := xiter.Reduce(func(sum int, v int) int {
	return sum + v
}, 0, seq1To100)
fmt.Println(sum)
// output:
// 5050
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func _range(a, b int) []int {
	var res []int
	for i := a; i < b; i++ {
		res = append(res, i)
	}
	return res
}

func main() {
	seq1To100 := xiter.FromSlice(_range(1, 101))
	sum := xiter.Reduce(func(sum int, v int) int {
		return sum + v
	}, 0, seq1To100)
	fmt.Println(sum)
}
```

#### Output

```
5050
```

</p>
</details>

<a name="Reduce2"></a>
## func [Reduce2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L360>)

```go
func Reduce2[Sum, K, V any](f func(Sum, K, V) Sum, sum Sum, seq Seq2[K, V]) Sum
```

Reduce2 combines the values in seq using f. For each pair k, v in seq, it updates sum = f\(sum, k, v\) and then returns the final sum. For example, if iterating over seq yields \(k1, v1\), \(k2, v2\), \(k3, v3\) Reduce returns f\(f\(f\(sum, k1, v1\), k2, v2\), k3, v3\).

<a name="ToMap"></a>
## func [ToMap](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L500>)

```go
func ToMap[K comparable, V any](seq Seq2[K, V]) (out map[K]V)
```



<a name="ToSlice"></a>
## func [ToSlice](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L445>)

```go
func ToSlice[T any](seq Seq[T]) (out []T)
```

ToSlice returns the elements in seq as a slice.

<a name="ToSliceN"></a>
## func [ToSliceN](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L790>)

```go
func ToSliceN[T any](seq Seq[T], n int) (out []T)
```

ToSliceN pull out n elements from seq.

<a name="ToSliceSeq2Key"></a>
## func [ToSliceSeq2Key](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L459>)

```go
func ToSliceSeq2Key[K, V any](seq Seq2[K, V]) (out []K)
```

ToSliceSeq2Key returns the keys in seq as a slice.

Example:

```
seq := FromMap(map[string]int{"a": 1, "b": 2})
keys := ToSliceSeq2Key(seq)
// keys will contain: []string{"a", "b"} (order may vary)
```

<a name="ToSliceSeq2Value"></a>
## func [ToSliceSeq2Value](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L473>)

```go
func ToSliceSeq2Value[K, V any](seq Seq2[K, V]) (out []V)
```

ToSliceSeq2Value returns the values in seq as a slice.

Example:

```
seq := FromMap(map[string]int{"a": 1, "b": 2})
values := ToSliceSeq2Value(seq)
// values will contain: []int{1, 2} (order may vary)
```

<a name="Seq"></a>
## type [Seq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L19>)

Seq is a sequence of elements provided by an iterator\-like function. We made this alias Seq to iter.Seq for providing a compatible interface in lower go versions.

```go
type Seq[V any] iter.Seq[V]
```

<a name="Concat"></a>
### func [Concat](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L38>)

```go
func Concat[V any](seqs ...Seq[V]) Seq[V]
```

Concat returns a Seq over the concatenation of the sequences. It combines multiple Seqs into a single Seq by iterating each Seq one by one in order.

Example:

```
seq1 := xiter.FromSlice([]int{1, 2})
seq2 := xiter.FromSlice([]int{3, 4})
seq3 := xiter.FromSlice([]int{5, 6})
combined := xiter.Concat(seq1, seq2, seq3)
fmt.Println(xiter.ToSlice(combined))
// output:
// [1 2 3 4 5 6]
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq1 := xiter.FromSlice([]int{1, 2})
	seq2 := xiter.FromSlice([]int{3, 4})
	seq3 := xiter.FromSlice([]int{5, 6})
	combined := xiter.Concat(seq1, seq2, seq3)
	fmt.Println(xiter.ToSlice(combined))
}
```

#### Output

```
[1 2 3 4 5 6]
```

</p>
</details>

<a name="Filter"></a>
### func [Filter](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L140>)

```go
func Filter[V any](f func(V) bool, seq Seq[V]) Seq[V]
```

Filter returns a Seq over seq that only includes the values v for which f\(v\) is true.

Example:

```
seq := FromSlice([]int{1, 2, 3, 4, 5})
evenNumbers := Filter(func(v int) bool { return v%2 == 0 }, seq)
// evenNumbers will yield: 2, 4
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq := xiter.FromSlice([]int{1, 2, 3, 4, 5})
	evenNumbers := xiter.Filter(func(v int) bool { return v%2 == 0 }, seq)
	fmt.Println(xiter.ToSlice(evenNumbers))
}
```

#### Output

```
[2 4]
```

</p>
</details>

<a name="FromMapKeys"></a>
### func [FromMapKeys](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L504>)

```go
func FromMapKeys[K comparable, V any](m map[K]V) Seq[K]
```



<a name="FromMapValues"></a>
### func [FromMapValues](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L508>)

```go
func FromMapValues[K comparable, V any](m map[K]V) Seq[V]
```



<a name="FromSlice"></a>
### func [FromSlice](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L29>)

```go
func FromSlice[T any](in []T) Seq[T]
```

FromSlice received a slice and returned a Seq for this slice.

<a name="FromSliceReverse"></a>
### func [FromSliceReverse](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L60>)

```go
func FromSliceReverse[T any, Slice ~[]T](in Slice) Seq[T]
```



<a name="FromSliceShuffle"></a>
### func [FromSliceShuffle](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L870>)

```go
func FromSliceShuffle[T any](in []T) Seq[T]
```

FromSliceShuffle return a seq that shuffle the elements in the input slice.

Example:

```
seq := FromSlice([]int{1, 2, 3, 4, 5})
shuffledSeq := FromSliceShuffle(ToSlice(seq))
// shuffledSeq will yield a shuffled sequence of 1, 2, 3, 4, 5
```

<a name="Limit"></a>
### func [Limit](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L173>)

```go
func Limit[V any](seq Seq[V], n int) Seq[V]
```

Limit returns an iterator over the first n values of seq. If n is less than or equal to 0, an empty sequence is returned.

Example:

```
seq := xiter.FromSlice([]int{1, 2, 3, 4, 5})
limitedSeq := xiter.Limit(seq, 3)
fmt.Println(xiter.ToSlice(limitedSeq))
// output:
// [1 2 3]
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq := xiter.FromSlice([]int{1, 2, 3, 4, 5})
	limitedSeq := xiter.Limit(seq, 3)
	fmt.Println(xiter.ToSlice(limitedSeq))
}
```

#### Output

```
[1 2 3]
```

</p>
</details>

<a name="Map"></a>
### func [Map](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L218>)

```go
func Map[In, Out any](f func(In) Out, seq Seq[In]) Seq[Out]
```

Map returns a Seq over the results of applying f to each value in seq.

Example:

```
seq := xiter.FromSlice([]int{1, 2, 3})
doubled := xiter.Map(func(v int) int { return v * 2 }, seq)
fmt.Println(xiter.ToSlice(doubled))
// output:
// [2 4 6]
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq := xiter.FromSlice([]int{1, 2, 3})
	doubled := xiter.Map(func(v int) int { return v * 2 }, seq)
	fmt.Println(xiter.ToSlice(doubled))
}
```

#### Output

```
[2 4 6]
```

</p>
</details>

<a name="Merge"></a>
### func [Merge](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L251>)

```go
func Merge[V cmp.Ordered](x, y Seq[V]) Seq[V]
```

Merge merges two sequences of ordered values. Values appear in the output once for each time they appear in x and once for each time they appear in y. If the two input sequences are not ordered, the output sequence will not be ordered, but it will still contain every value from x and y exactly once.

Merge is equivalent to calling MergeFunc with cmp.Compare\[V\] as the ordering function.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	oddSeq := xiter.FromSlice([]int{1, 3, 5})
	evenSeq := xiter.FromSlice([]int{2, 4, 6})
	mergedSeq := xiter.Merge(oddSeq, evenSeq)
	fmt.Println(xiter.ToSlice(mergedSeq))
}
```

#### Output

```
[1 2 3 4 5 6]
```

</p>
</details>

<a name="MergeFunc"></a>
### func [MergeFunc](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L263>)

```go
func MergeFunc[V any](x, y Seq[V], f func(V, V) int) Seq[V]
```

MergeFunc merges two sequences of values ordered by the function f. Values appear in the output once for each time they appear in x and once for each time they appear in y. When equal values appear in both sequences, the output contains the values from x before the values from y. If the two input sequences are not ordered by f, the output sequence will not be ordered by f, but it will still contain every value from x and y exactly once.

<a name="Repeat"></a>
### func [Repeat](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L83>)

```go
func Repeat[T any](seq Seq[T], count int) Seq[T]
```

Repeat return a seq that repeat seq for count times.

<a name="Replace"></a>
### func [Replace](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L835>)

```go
func Replace[T comparable](seq Seq[T], from, to T, n int) Seq[T]
```

Replace return a seq that replace from \-\> to

Example:

```
seq := FromSlice([]int{1, 2, 3, 2, 4})
replacedSeq := Replace(seq, 2, 99, -1) // Replace all 2s with 99
// replacedSeq will yield: 1, 99, 3, 99, 4
```

<a name="ReplaceAll"></a>
### func [ReplaceAll](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L859>)

```go
func ReplaceAll[T comparable](seq Seq[T], from, to T) Seq[T]
```

ReplaceAll return a seq that replace all from \-\> to

Example:

```
seq := FromSlice([]int{1, 2, 3, 2, 4})
replacedSeq := ReplaceAll(seq, 2, 99)
// replacedSeq will yield: 1, 99, 3, 99, 4
```

<a name="Reverse"></a>
### func [Reverse](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L71>)

```go
func Reverse[T any](seq Seq[T]) Seq[T]
```

Reverse return a reversed seq.

<a name="Seq2KeyToSeq"></a>
### func [Seq2KeyToSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L480>)

```go
func Seq2KeyToSeq[K, V any](in Seq2[K, V]) Seq[K]
```



<a name="Seq2ValueToSeq"></a>
### func [Seq2ValueToSeq](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L490>)

```go
func Seq2ValueToSeq[K, V any](in Seq2[K, V]) Seq[V]
```



<a name="Skip"></a>
### func [Skip](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L814>)

```go
func Skip[T any](seq Seq[T], n int) Seq[T]
```

Skip return a seq that skip n elements from seq.

<a name="Zip"></a>
### func [Zip](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L384>)

```go
func Zip[V1, V2 any](x Seq[V1], y Seq[V2]) Seq[Zipped[V1, V2]]
```

Zip returns an iterator that iterates x and y in parallel, yielding Zipped values of successive elements of x and y. If one sequence ends before the other, the iteration continues with Zipped values in which either Ok1 or Ok2 is false, depending on which sequence ended first.

Zip is a useful building block for adapters that process pairs of sequences. For example, Equal can be defined as:

```
func Equal[V comparable](x, y Seq[V]) bool {
	for z := range Zip(x, y) {
		if z.Ok1 != z.Ok2 || z.V1 != z.V2 {
			return false
		}
	}
	return true
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/dashjay/xiter/pkg/xiter"
)

func main() {
	seq1 := xiter.FromSlice([]int{1, 2, 3})
	seq2 := xiter.FromSlice([]int{11, 22, 33})
	zipped := xiter.Zip(seq1, seq2)
	out := xiter.ToSlice(zipped)
	for _, o := range out {
		fmt.Println(o.V1, o.V2)
	}
}
```

#### Output

```
1 11
2 22
3 33
```

</p>
</details>

<a name="Zip2"></a>
### func [Zip2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L422>)

```go
func Zip2[K1, V1, K2, V2 any](x Seq2[K1, V1], y Seq2[K2, V2]) Seq[Zipped2[K1, V1, K2, V2]]
```

Zip2 returns an iterator that iterates x and y in parallel, yielding Zipped2 values of successive elements of x and y. If one sequence ends before the other, the iteration continues with Zipped2 values in which either Ok1 or Ok2 is false, depending on which sequence ended first.

Zip2 is a useful building block for adapters that process pairs of sequences. For example, Equal2 can be defined as:

```
func Equal2[K, V comparable](x, y Seq2[K, V]) bool {
	for z := range Zip2(x, y) {
		if z.Ok1 != z.Ok2 || z.K1 != z.K2 || z.V1 != z.V2 {
			return false
		}
	}
	return true
}
```

<a name="Seq2"></a>
## type [Seq2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L23>)

Seq2 is a sequence of key/value pair provided by an iterator\-like function. We made this alias Seq2 to iter.Seq2 for providing a compatible interface in lower go versions.

```go
type Seq2[K, V any] iter.Seq2[K, V]
```

<a name="Concat2"></a>
### func [Concat2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L52>)

```go
func Concat2[K, V any](seqs ...Seq2[K, V]) Seq2[K, V]
```

Concat2 returns an Seq2 over the concatenation of the given Seq2s. Like Concat but run with Seq2

<a name="Filter2"></a>
### func [Filter2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L153>)

```go
func Filter2[K, V any](f func(K, V) bool, seq Seq2[K, V]) Seq2[K, V]
```

Filter2 returns an Seq over seq that only includes the key\-value pairs k, v for which f\(k, v\) is true. Like Filter but run with Seq2

<a name="FromMapKeyAndValues"></a>
### func [FromMapKeyAndValues](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L512>)

```go
func FromMapKeyAndValues[K comparable, V any](m map[K]V) Seq2[K, V]
```



<a name="FromSliceIdx"></a>
### func [FromSliceIdx](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L40>)

```go
func FromSliceIdx[T any](in []T) Seq2[int, T]
```

FromSliceIdx received a slice and returned a Seq2 for this slice, key is index.

<a name="Limit2"></a>
### func [Limit2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L192>)

```go
func Limit2[K, V any](seq Seq2[K, V], n int) Seq2[K, V]
```

Limit2 returns a Seq over Seq2 that stops after n key\-value pairs. Like Limit but run with Seq2

<a name="Map2"></a>
### func [Map2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L230-L232>)

```go
func Map2[KIn, VIn, KOut, VOut any](f func(KIn, VIn) (KOut, VOut), seq Seq2[KIn, VIn]) Seq2[KOut, VOut]
```

Map2 returns a Seq2 over the results of applying f to each key\-value pair in seq. Like Map but run with Seq2

<a name="Merge2"></a>
### func [Merge2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L297>)

```go
func Merge2[K cmp.Ordered, V any](x, y Seq2[K, V]) Seq2[K, V]
```

Merge2 merges two sequences of key\-value pairs ordered by their keys. Pairs appear in the output once for each time they appear in x and once for each time they appear in y. If the two input sequences are not ordered by their keys, the output sequence will not be ordered by its keys, but it will still contain every pair from x and y exactly once.

Merge2 is equivalent to calling MergeFunc2 with cmp.Compare\[K\] as the ordering function.

<a name="MergeFunc2"></a>
### func [MergeFunc2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter.go#L309>)

```go
func MergeFunc2[K, V any](x, y Seq2[K, V], f func(K, K) int) Seq2[K, V]
```

MergeFunc2 merges two sequences of key\-value pairs ordered by the function f. Pairs appear in the output once for each time they appear in x and once for each time they appear in y. When pairs with equal keys appear in both sequences, the output contains the pairs from x before the pairs from y. If the two input sequences are not ordered by f, the output sequence will not be ordered by f, but it will still contain every pair from x and y exactly once.

<a name="Zipped"></a>
## type [Zipped](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L21-L26>)

A Zipped is a pair of zipped values, one of which may be missing, drawn from two different sequences.

```go
type Zipped[V1, V2 any] struct {
    V1  V1
    Ok1 bool // whether V1 is present (if not, it will be zero)
    V2  V2
    Ok2 bool // whether V2 is present (if not, it will be zero)
}
```

<a name="Zipped2"></a>
## type [Zipped2](<https://github.com/dashjay/xiter/blob/main/pkg/xiter/xiter_common.go#L10-L17>)

A Zipped2 is a pair of zipped key\-value pairs, one of which may be missing, drawn from two different sequences.

```go
type Zipped2[K1, V1, K2, V2 any] struct {
    K1  K1
    V1  V1
    Ok1 bool // whether K1, V1 are present (if not, they will be zero)
    K2  K2
    V2  V2
    Ok2 bool // whether K2, V2 are present (if not, they will be zero)
}
```

# xslice

```go
import "github.com/dashjay/xiter/pkg/xslice"
```

## Index

- [func All\[T any\]\(in \[\]T, f func\(T\) bool\) bool](<#All>)
- [func Any\[T any\]\(in \[\]T, f func\(T\) bool\) bool](<#Any>)
- [func Avg\[T constraints.Number\]\(in \[\]T\) float64](<#Avg>)
- [func AvgBy\[V any, T constraints.Number\]\(in \[\]V, f func\(V\) T\) float64](<#AvgBy>)
- [func AvgN\[T constraints.Number\]\(inputs ...T\) float64](<#AvgN>)
- [func Chunk\[T any, Slice \~\[\]T\]\(in Slice, chunkSize int\) \[\]Slice](<#Chunk>)
- [func ChunkInPlace\[T any, Slice \~\[\]T\]\(in Slice, chunkSize int\) \[\]Slice](<#ChunkInPlace>)
- [func Clone\[T any\]\(in \[\]T\) \[\]T](<#Clone>)
- [func CloneBy\[T any, U any\]\(in \[\]T, f func\(T\) U\) \[\]U](<#CloneBy>)
- [func Concat\[T any\]\(vs ...\[\]T\) \[\]T](<#Concat>)
- [func Contains\[T comparable\]\(in \[\]T, v T\) bool](<#Contains>)
- [func ContainsAll\[T comparable\]\(in \[\]T, v \[\]T\) bool](<#ContainsAll>)
- [func ContainsAny\[T comparable\]\(in \[\]T, v \[\]T\) bool](<#ContainsAny>)
- [func ContainsBy\[T any\]\(in \[\]T, f func\(T\) bool\) bool](<#ContainsBy>)
- [func Count\[T any\]\(in \[\]T\) int](<#Count>)
- [func Find\[T any\]\(in \[\]T, f func\(T\) bool\) \(val T, found bool\)](<#Find>)
- [func FindO\[T any\]\(in \[\]T, f func\(T\) bool\) optional.O\[T\]](<#FindO>)
- [func ForEach\[T any\]\(in \[\]T, f func\(T\) bool\)](<#ForEach>)
- [func ForEachIdx\[T any\]\(in \[\]T, f func\(idx int, v T\) bool\)](<#ForEachIdx>)
- [func Head\[T any\]\(in \[\]T\) \(v T, hasOne bool\)](<#Head>)
- [func HeadO\[T any\]\(in \[\]T\) optional.O\[T\]](<#HeadO>)
- [func Join\[T \~string\]\(in \[\]T, sep T\) T](<#Join>)
- [func Map\[T any, U any\]\(in \[\]T, f func\(T\) U\) \[\]U](<#Map>)
- [func Max\[T constraints.Ordered\]\(in \[\]T\) optional.O\[T\]](<#Max>)
- [func MaxBy\[T constraints.Ordered\]\(in \[\]T, f func\(T, T\) bool\) optional.O\[T\]](<#MaxBy>)
- [func MaxN\[T constraints.Ordered\]\(in ...T\) optional.O\[T\]](<#MaxN>)
- [func Min\[T constraints.Ordered\]\(in \[\]T\) optional.O\[T\]](<#Min>)
- [func MinBy\[T constraints.Ordered\]\(in \[\]T, f func\(T, T\) bool\) optional.O\[T\]](<#MinBy>)
- [func MinN\[T constraints.Ordered\]\(in ...T\) optional.O\[T\]](<#MinN>)
- [func Repeat\[T any, Slice \~\[\]T\]\(in Slice, count int\) Slice](<#Repeat>)
- [func RepeatBy\[T any\]\(n int, f func\(i int\) T\) \[\]T](<#RepeatBy>)
- [func Replace\[T comparable, Slice \~\[\]T\]\(in Slice, from, to T, count int\) \[\]T](<#Replace>)
- [func ReplaceAll\[T comparable, Slice \~\[\]T\]\(in Slice, from, to T\) \[\]T](<#ReplaceAll>)
- [func Reverse\[T any, Slice \~\[\]T\]\(in Slice\)](<#Reverse>)
- [func ReverseClone\[T any, Slice \~\[\]T\]\(in Slice\) Slice](<#ReverseClone>)
- [func Shuffle\[T any, Slice \~\[\]T\]\(in Slice\) Slice](<#Shuffle>)
- [func ShuffleInPlace\[T any, Slice \~\[\]T\]\(in Slice\)](<#ShuffleInPlace>)
- [func Subset\[T any, Slice \~\[\]T\]\(in Slice, start, count int\) Slice](<#Subset>)
- [func SubsetInPlace\[T any, Slice \~\[\]T\]\(in Slice, start int, count int\) Slice](<#SubsetInPlace>)


<a name="All"></a>
## func [All](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L19>)

```go
func All[T any](in []T, f func(T) bool) bool
```

All returns true if all elements in the slice satisfy the condition provided by f. return false if any element in the slice does not satisfy the condition provided by f.

EXAMPLE:

```
xslice.All([]int{1, 2, 3}, func(x int) bool { return x > 0 }) üëâ true
xslice.All([]int{-1, 1, 2, 3}, func(x int) bool { return x > 0 }) üëâ false
```

<a name="Any"></a>
## func [Any](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L30>)

```go
func Any[T any](in []T, f func(T) bool) bool
```

Any returns true if any element in the slice satisfy the condition provided by f. return false if none of element in the slice satisfy the condition provided by f.

EXAMPLE:

```
xslice.Any([]int{0, 1, 2, 3}, func(x int) bool { return x == 0 }) üëâ true
xslice.Any([]int{0, 1, 2, 3}, func(x int) bool { return x == -1 }) üëâ false
```

<a name="Avg"></a>
## func [Avg](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L40>)

```go
func Avg[T constraints.Number](in []T) float64
```

Avg returns the average value of the items in slice \(float64\).

EXAMPLE:

```
xslice.Avg([]int{1, 2, 3}) üëâ float(2)
xslice.Avg([]int{}) üëâ float(0)
```

<a name="AvgBy"></a>
## func [AvgBy](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L62>)

```go
func AvgBy[V any, T constraints.Number](in []V, f func(V) T) float64
```

AvgBy returns the averaged of each item's value evaluated by f.

EXAMPLE:

```
xslice.AvgBy([]string{"1", "2", "3"}, func(x string) int {
	i, _ := strconv.Atoi(x)
	return i
}) üëâ float(2)
```

<a name="AvgN"></a>
## func [AvgN](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L50>)

```go
func AvgN[T constraints.Number](inputs ...T) float64
```

AvgN returns the average value of the items

EXAMPLE:

```
xslice.AvgN(1, 2, 3) üëâ float(2)
xslice.AvgN() üëâ float(0)
```

<a name="Chunk"></a>
## func [Chunk](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L462>)

```go
func Chunk[T any, Slice ~[]T](in Slice, chunkSize int) []Slice
```

Chunk returns a new slice with the elements in the slice chunked into smaller slices of the specified size.

EXAMPLE:

```
xslice.Chunk([]int{1, 2, 3, 4, 5}, 2) üëâ [[1, 2], [3, 4], [5]]
xslice.Chunk([]int{1, 2, 3, 4, 5}, 10) üëâ [[1, 2, 3, 4, 5]]
xslice.Chunk([]int{1, 2, 3, 4, 5}, 0) üëâ []int{}
```

<a name="ChunkInPlace"></a>
## func [ChunkInPlace](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L483>)

```go
func ChunkInPlace[T any, Slice ~[]T](in Slice, chunkSize int) []Slice
```

ChunkInPlace returns a new slice with the elements in the slice chunked into smaller slices of the specified size. This function will not copy the elements, has no extra costs. EXAMPLE:

```
xslice.Chunk([]int{1, 2, 3, 4, 5}, 2) üëâ [[1, 2], [3, 4], [5]]
xslice.Chunk([]int{1, 2, 3, 4, 5}, 10) üëâ [[1, 2, 3, 4, 5]]
xslice.Chunk([]int{1, 2, 3, 4, 5}, 0) üëâ []int{}
```

<a name="Clone"></a>
## func [Clone](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L282>)

```go
func Clone[T any](in []T) []T
```

Clone returns a copy of the slice.

EXAMPLE:

```
xslice.Clone([]int{1, 2, 3}) üëâ [1, 2, 3]
```

<a name="CloneBy"></a>
## func [CloneBy](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L295>)

```go
func CloneBy[T any, U any](in []T, f func(T) U) []U
```

CloneBy returns a copy of the slice with the results of applying the given function to every element in this slice.

EXAMPLE:

```
xslice.CloneBy([]int{1, 2, 3}, func(x int) int { return x * 2 }) üëâ [2, 4, 6]
xslice.CloneBy([]int{1, 2, 3}, strconv.Itoa) üëâ ["1", "2", "3"]
```

<a name="Concat"></a>
## func [Concat](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L308>)

```go
func Concat[T any](vs ...[]T) []T
```

Concat concatenates the slices.

EXAMPLE:

```
xslice.Concat([]int{1, 2, 3}, []int{4, 5, 6}) üëâ [1, 2, 3, 4, 5, 6]
xslice.Concat([]int{1, 2, 3}, []int{}) üëâ [1, 2, 3]
```

<a name="Contains"></a>
## func [Contains](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L72>)

```go
func Contains[T comparable](in []T, v T) bool
```

Contains returns true if the slice contains the value v.

EXAMPLE:

```
xslice.Contains([]int{1, 2, 3}, 1) üëâ true
xslice.Contains([]int{-1, 2, 3}, 1) üëâ false
```

<a name="ContainsAll"></a>
## func [ContainsAll](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L111>)

```go
func ContainsAll[T comparable](in []T, v []T) bool
```

ContainsAll returns true if the slice contains all values in v.

EXAMPLE:

```
xslice.ContainsAll([]string{"1", "2", "3"}, []string{"1", "2", "3"})  üëâ true
xslice.ContainsAll([]string{"1", "2", "3"}, []string{"1", "99", "1000"}) üëâ false
xslice.ContainsAll([]string{"1", "2", "3"}, []string{}) üëâ true
```

<a name="ContainsAny"></a>
## func [ContainsAny](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L100>)

```go
func ContainsAny[T comparable](in []T, v []T) bool
```

ContainsAny returns true if the slice contains any value in v.

EXAMPLE:

```
xslice.ContainsAny([]string{"1", "2", "3"}, []string{"1", "99", "1000"}) üëâ true
xslice.ContainsAny([]string{"1", "2", "3"}, []string{"-1"}) üëâ false
xslice.ContainsAny([]string{"1", "2", "3"}, []string{}) üëâ false
```

<a name="ContainsBy"></a>
## func [ContainsBy](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L89>)

```go
func ContainsBy[T any](in []T, f func(T) bool) bool
```

ContainsBy returns true if the slice contains the value v evaluated by f.

EXAMPLE:

```
xslice.ContainsBy([]string{"1", "2", "3"}, func(x string) bool {
	i, _ := strconv.Atoi(x)
	return i == 1
}) üëâ true

xslice.ContainsBy([]string{"1", "2", "3"}, func(x string) bool {
	i, _ := strconv.Atoi(x)
	return i == -1
}) üëâ false
```

<a name="Count"></a>
## func [Count](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L121>)

```go
func Count[T any](in []T) int
```

Count returns the number of items in the slice.

EXAMPLE:

```
xslice.Count([]int{1, 2, 3}) üëâ 3
xslice.Count([]int{}) üëâ 0
```

<a name="Find"></a>
## func [Find](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L131>)

```go
func Find[T any](in []T, f func(T) bool) (val T, found bool)
```

Find returns the first item in the slice that satisfies the condition provided by f.

EXAMPLE:

```
xslice.Find([]int{1, 2, 3}, func(x int) bool { return x == 1 })  üëâ 1, true
xslice.Find([]int{1, 2, 3}, func(x int) bool { return x == -1 }) üëâ 0, false
```

<a name="FindO"></a>
## func [FindO](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L141>)

```go
func FindO[T any](in []T, f func(T) bool) optional.O[T]
```

FindO returns the first item in the slice that satisfies the condition provided by f.

EXAMPLE:

```
xslice.FindO(_range(0, 10), func(x int) bool { return x == 1 }).Must() üëâ 1
xslice.FindO(_range(0, 10), func(x int) bool { return x == -1 }).Ok() üëâ false
```

<a name="ForEach"></a>
## func [ForEach](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L157>)

```go
func ForEach[T any](in []T, f func(T) bool)
```

ForEach iterates over each item in the slice, stop if f returns false.

EXAMPLE:

```
ForEach([]int{1, 2, 3}, func(x int) bool {
	fmt.Println(x)
	return true
}
Output:
1
2
3
```

<a name="ForEachIdx"></a>
## func [ForEachIdx](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L173>)

```go
func ForEachIdx[T any](in []T, f func(idx int, v T) bool)
```

ForEachIdx iterates over each item in the slice, stop if f returns false.

EXAMPLE:

```
ForEach([]int{1, 2, 3}, func(idx, x int) bool {
	fmt.Println(idx, x)
	return true
}
Output:
0 1
1 2
2 3
```

<a name="Head"></a>
## func [Head](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L193>)

```go
func Head[T any](in []T) (v T, hasOne bool)
```

Head returns the first item in the slice.

EXAMPLE:

```
optional.FromValue2(xslice.Head(_range(0, 10))).Must() üëâ 0
optional.FromValue2(xslice.Head(_range(0, 0))).Ok() üëâ false
```

<a name="HeadO"></a>
## func [HeadO](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L183>)

```go
func HeadO[T any](in []T) optional.O[T]
```

HeadO returns the first item in the slice.

EXAMPLE:

```
xslice.HeadO(_range(0, 10)).Must() üëâ 0
xslice.HeadO(_range(0, 0)).Ok() üëâ false
```

<a name="Join"></a>
## func [Join](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L203>)

```go
func Join[T ~string](in []T, sep T) T
```

Join joins the slice with sep.

EXAMPLE:

```
xslice.Join([]string{"1", "2", "3"}, ".") üëâ "1.2.3"
xslice.Join([]string{}, ".") üëâ ""
```

<a name="Map"></a>
## func [Map](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L269>)

```go
func Map[T any, U any](in []T, f func(T) U) []U
```

Map returns a new slice with the results of applying the given function to every element in this slice.

EXAMPLE:

```
xslice.Map([]int{1, 2, 3}, func(x int) int { return x * 2 }) üëâ [2, 4, 6]
xslice.Map([]int{1, 2, 3}, strconv.Itoa) üëâ ["1", "2", "3"]
```

<a name="Max"></a>
## func [Max](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L241>)

```go
func Max[T constraints.Ordered](in []T) optional.O[T]
```

Max returns the maximum value in the slice.

EXAMPLE:

```
xslice.Max([]int{1, 2, 3}) üëâ 3
xslice.Max([]int{}) üëâ 0
```

<a name="MaxBy"></a>
## func [MaxBy](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L259>)

```go
func MaxBy[T constraints.Ordered](in []T, f func(T, T) bool) optional.O[T]
```

MaxBy returns the maximum value evaluated by f in the slice.

EXAMPLE:

```
xslice.MaxBy([]int{1, 2, 3} /*less = */, func(a, b int) bool { return a > b }).Must() üëâ 1
```

<a name="MaxN"></a>
## func [MaxN](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L250>)

```go
func MaxN[T constraints.Ordered](in ...T) optional.O[T]
```

MaxN returns the maximum value in the slice.

EXAMPLE:

```
xslice.MaxN(1, 2, 3) üëâ 3
```

<a name="Min"></a>
## func [Min](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L213>)

```go
func Min[T constraints.Ordered](in []T) optional.O[T]
```

Min returns the minimum value in the slice.

EXAMPLE:

```
xslice.Min([]int{1, 2, 3}) üëâ 1
xslice.Min([]int{}) üëâ 0
```

<a name="MinBy"></a>
## func [MinBy](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L231>)

```go
func MinBy[T constraints.Ordered](in []T, f func(T, T) bool) optional.O[T]
```

MinBy returns the minimum value evaluated by f in the slice.

EXAMPLE:

```
xslice.MinBy([]int{3, 2, 1} /*less = */, func(a, b int) bool { return a > b }).Must() üëâ 3
```

<a name="MinN"></a>
## func [MinN](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L222>)

```go
func MinN[T constraints.Ordered](in ...T) optional.O[T]
```

MinN returns the minimum value in the slice.

EXAMPLE:

```
xslice.MinN(1, 2, 3) üëâ 1
```

<a name="Repeat"></a>
## func [Repeat](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L413>)

```go
func Repeat[T any, Slice ~[]T](in Slice, count int) Slice
```

Repeat returns a new slice with the elements repeated 'count' times.

EXAMPLE:

```
xslice.Repeat([]int{1, 2, 3}, 3) üëâ [1, 2, 3, 1, 2, 3, 1, 2, 3]
xslice.Repeat([]int{1, 2, 3}, 0) üëâ []int{}
```

<a name="RepeatBy"></a>
## func [RepeatBy](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L423>)

```go
func RepeatBy[T any](n int, f func(i int) T) []T
```

RepeatBy returns a new slice with the elements return by f repeated 'count' times.

EXAMPLE:

```
xslice.RepeatBy(3, func(i int) int { return i }) üëâ [0, 1, 2]
xslice.RepeatBy(3, func(i int) string { return strconv.Itoa(i) }) üëâ []string{"1", "2", "3"}
```

<a name="Replace"></a>
## func [Replace](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L368>)

```go
func Replace[T comparable, Slice ~[]T](in Slice, from, to T, count int) []T
```

Replace replaces the count elements in the slice from 'from' to 'to'.

EXAMPLE:

```
xslice.Replace([]int{1, 2, 3}, 2, 4, 1) üëâ [1, 4, 3]
xslice.Replace([]int{1, 2, 2}, 2, 4, -1) üëâ [1, 4, 4]
```

<a name="ReplaceAll"></a>
## func [ReplaceAll](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L378>)

```go
func ReplaceAll[T comparable, Slice ~[]T](in Slice, from, to T) []T
```

ReplaceAll replaces all elements in the slice from 'from' to 'to'.

EXAMPLE:

```
xslice.ReplaceAll([]int{1, 2, 3}, 2, 4) üëâ [1, 4, 3]
xslice.ReplaceAll([]int{1, 2, 2}, 2, 4) üëâ [1, 4, 4]
```

<a name="Reverse"></a>
## func [Reverse](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L401>)

```go
func Reverse[T any, Slice ~[]T](in Slice)
```

Reverse reverses the slice.

EXAMPLE:

```
xslice.Reverse([]int{1, 2, 3}) üëâ [3, 2, 1]
xslice.Reverse([]int{}) üëâ []int{}
```

<a name="ReverseClone"></a>
## func [ReverseClone](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L389>)

```go
func ReverseClone[T any, Slice ~[]T](in Slice) Slice
```

ReverseClone reverses the slice.

EXAMPLE:

```
xslice.ReverseClone([]int{1, 2, 3}) üëâ [3, 2, 1]
xslice.ReverseClone([]int{}) üëâ []int{}
xslice.ReverseClone([]int{3, 2, 1}) üëâ [1, 2, 3]
```

<a name="Shuffle"></a>
## func [Shuffle](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L437>)

```go
func Shuffle[T any, Slice ~[]T](in Slice) Slice
```

Shuffle shuffles the slice.

EXAMPLE:

```
xslice.Shuffle([]int{1, 2, 3}) üëâ [2, 1, 3] (random)
xslice.Shuffle([]int{}) üëâ []int{}
```

<a name="ShuffleInPlace"></a>
## func [ShuffleInPlace](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L447>)

```go
func ShuffleInPlace[T any, Slice ~[]T](in Slice)
```

ShuffleInPlace shuffles the slice.

EXAMPLE:

```
array := []int{1, 2, 3}
xslice.ShuffleInPlace(array) üëâ [2, 1, 3] (random)
```

<a name="Subset"></a>
## func [Subset](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L323>)

```go
func Subset[T any, Slice ~[]T](in Slice, start, count int) Slice
```

Subset returns a subset slice from the slice. if start \< \-1 means that we take subset from right\-to\-left

EXAMPLE:

```
xslice.Subset([]int{1, 2, 3}, 0, 2) üëâ [1, 2]
xslice.Subset([]int{1, 2, 3}, -1, 2) üëâ [2, 3]
```

<a name="SubsetInPlace"></a>
## func [SubsetInPlace](<https://github.com/dashjay/xiter/blob/main/pkg/xslice/xslice.go#L343>)

```go
func SubsetInPlace[T any, Slice ~[]T](in Slice, start int, count int) Slice
```

SubsetInPlace returns a subset slice copied from the slice. if start \< \-1 means that we take subset from right\-to\-left EXAMPLE:

```
xslice.SubsetInPlace([]int{1, 2, 3}, 0, 2) üëâ [1, 2]
xslice.SubsetInPlace([]int{1, 2, 3}, -1, 2) üëâ [2, 3]
```

# constraints

```go
import "github.com/dashjay/xiter/pkg/internal/constraints"
```

Package constraints defined constraints for generics tools

## Index

- [type Float](<#Float>)
- [type Integer](<#Integer>)
- [type Number](<#Number>)
- [type Ordered](<#Ordered>)


<a name="Float"></a>
## type [Float](<https://github.com/dashjay/xiter/blob/main/pkg/internal/constraints/constraints.go#L4-L6>)



```go
type Float interface {
    // contains filtered or unexported methods
}
```

<a name="Integer"></a>
## type [Integer](<https://github.com/dashjay/xiter/blob/main/pkg/internal/constraints/constraints.go#L8-L10>)



```go
type Integer interface {
    // contains filtered or unexported methods
}
```

<a name="Number"></a>
## type [Number](<https://github.com/dashjay/xiter/blob/main/pkg/internal/constraints/constraints.go#L12-L14>)



```go
type Number interface {
    // contains filtered or unexported methods
}
```

<a name="Ordered"></a>
## type [Ordered](<https://github.com/dashjay/xiter/blob/main/pkg/internal/constraints/constraints.go#L16-L18>)



```go
type Ordered interface {
    // contains filtered or unexported methods
}
```

# xassert

```go
import "github.com/dashjay/xiter/pkg/internal/xassert"
```

## Index

- [func MustBePositive\[T constraints.Number\]\(in T\)](<#MustBePositive>)


<a name="MustBePositive"></a>
## func [MustBePositive](<https://github.com/dashjay/xiter/blob/main/pkg/internal/xassert/xassert.go#L9>)

```go
func MustBePositive[T constraints.Number](in T)
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
